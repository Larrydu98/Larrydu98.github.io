(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{588:function(_,t,v){"use strict";v.r(t);var a=v(10),r=Object(a.a)({},(function(){var _=this,t=_.$createElement,v=_._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"_1-char、varchar的区别是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-char、varchar的区别是什么"}},[_._v("#")]),_._v(" 1. char、varchar的区别是什么？")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("CHAR")]),_._v("的长度是不可变的，而"),v("strong",[_._v("VARCHAR")]),_._v("的长度是可变的，也就是说，定义一个CHAR[10]和VARCHAR[10],如果存进去的是‘ABCD’, 那么CHAR所占的长度依然为10，除了字符‘ABCD’外，后面跟六个空格，而VARCHAR的长度变为4了，取数据的时候，CHAR类型的要用trim()去掉多余的空格，而VARCHAR类型是不需要的。")]),_._v(" "),v("li",[v("strong",[_._v("CHAR")]),_._v("的存取速度要比"),v("strong",[_._v("VARCHAR")]),_._v("快得多，因为其长度固定，方便程序的存储与查找；但是CHAR为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可以说是以空间换取时间效率，而VARCHAR则是以空间效率为首位的。")]),_._v(" "),v("li",[v("strong",[_._v("char")]),_._v("的存储方式是，一个英文(ASCII)占用一个字符，一个汉字占用两个字符；而"),v("strong",[_._v("VARCHAR")]),_._v("的存储方式是一个英文占用两个字符，一个汉字占用两个字符")]),_._v(" "),v("li",[v("code",[_._v("char")]),_._v("会删除字符的末尾的空格，但是"),v("code",[_._v("varchar")]),_._v("不会")]),_._v(" "),v("li",[_._v("两者的存储数据都是非unicode的字符数据。")])]),_._v(" "),v("h2",{attrs:{id:"_2-数据库中的事务的四大特性-acid"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-数据库中的事务的四大特性-acid"}},[_._v("#")]),_._v(" 2. 数据库中的事务的四大特性（ACID）")]),_._v(" "),v("h3",{attrs:{id:"什么是脏读-幻读-不可重复读"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是脏读-幻读-不可重复读"}},[_._v("#")]),_._v(" 什么是脏读？幻读？不可重复读？")]),_._v(" "),v("ul",[v("li",[_._v("脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。")]),_._v(" "),v("li",[_._v("不可重复读(Non-repeatable read)：在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。")]),_._v(" "),v("li",[_._v("幻读(Phantom Read)：在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列 (Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发 现有几列数据是它先前所没有的。")])]),_._v(" "),v("h3",{attrs:{id:"事务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务"}},[_._v("#")]),_._v(" 事务")]),_._v(" "),v("blockquote",[v("p",[_._v("什么是事务：")]),_._v(" "),v("p",[_._v("作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。 简单的说，事务就是并发控制的单位，是用户定义的一个操作序列")])]),_._v(" "),v("ol",[v("li",[v("p",[_._v("**原子性：**原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。")])]),_._v(" "),v("li",[v("p",[_._v("**一致性：**致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。")]),_._v(" "),v("p",[_._v("例子：拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("隔离性（Isolation）")]),_._v("：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。")]),_._v(" "),v("p",[_._v("即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。")]),_._v(" "),v("p",[v("strong",[_._v("四种隔离级别")])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("读未提交（READ UNCOMMITTED）")]),_._v(" "),v("blockquote",[v("p",[_._v("在读未提交隔离级别下，事务A可以读取到事务B修改过但未提交的数据;可能发生脏读、不可重复读和幻读问题，一般很少使用此隔离级别。")])])]),_._v(" "),v("li",[v("p",[_._v("读已提交（READ COMMITTED）")]),_._v(" "),v("blockquote",[v("p",[_._v("事务B只能在事务A修改过并且已提交后才能读取到事务B修改的数据。")]),_._v(" "),v("p",[_._v("读已提交隔离级别解决了脏读的问题，但可能发生不可重复读和幻读问题，一般很少使用此隔离级别。")])])]),_._v(" "),v("li",[v("p",[_._v("可重复读（REPEATABLE READ）")]),_._v(" "),v("blockquote",[v("p",[_._v("在可重复读隔离级别下，事务B只能在事务A修改过数据并提交后，自己也提交事务后，才能读取到事务B修改的数据。")]),_._v(" "),v("p",[_._v("可重复读隔离级别解决了脏读和不可重复读的问题，但可能发生幻读问题。")])])]),_._v(" "),v("li",[v("p",[_._v("可串行化（SERIALIZABLE）")]),_._v(" "),v("blockquote",[v("p",[_._v("这是最高的隔离级别,可以解决上面提到的所有问题,因为他强制将所以的操作串行执行,这会导致并发性 能极速下降,因此也不是很常用.")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/202205151939513.png",alt:"image-20220515193946330"}})]),_._v(" "),v("p",[v("a",{attrs:{href:"https://developer.aliyun.com/article/743691",target:"_blank",rel:"noopener noreferrer"}},[_._v("四种隔离级别"),v("OutboundLink")],1)])])])]),_._v(" "),v("li",[v("p",[_._v("**持久性（Durability）**持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。")])])]),_._v(" "),v("p",[v("strong",[_._v("在这四个特性中，原子性是基础，隔离性是手段，一致性是约束 条件，而持久性是我们的目的。")])]),_._v(" "),v("h2",{attrs:{id:"_3-什么是关系型数据库"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-什么是关系型数据库"}},[_._v("#")]),_._v(" 3. 什么是关系型数据库？")]),_._v(" "),v("p",[_._v("关系型数据库，关系型数据库是依据关系模型来创建的数据库。其以行和列的形式存储数据，以便于用户理 解，关系型数据库这一系列的行和列被称为表，一组表组成了数据库。")]),_._v(" "),v("h3",{attrs:{id:"关系型数据库特点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#关系型数据库特点"}},[_._v("#")]),_._v(" 关系型数据库特点")]),_._v(" "),v("ol",[v("li",[_._v("数据集中控制。在文件管理方法中，文件是分散的，每个用户或每种处理都有各自的文件，这些文 件之间一般是没有联系的，因此，不能按照统一的方法来控制、维护和管理。而数据库则很好地克 服了这一缺点，可以集中控制、维护和管理有关数据。")]),_._v(" "),v("li",[_._v("数据独立性高。数据库中的数据独立于应用程序，包括数据的物理独立性和逻辑独立性，给数据库 的使用、调整、优化和进一步扩充提供了方便，提高了数据库应用系统的稳定性。")]),_._v(" "),v("li",[_._v("数据共享性好。数据库中的数据可以供多个用户使用，每个用户只与库中的一部分数据发生联系； 用户数据可以重叠，用户可以同时存取数据而互不影响，大大提高了数据库的使用效率。")]),_._v(" "),v("li",[_._v("数据冗余度小。数据库中的数据不是面向应用，而是面向系统。数据统一定义、组织和存储，集中 管理，避免了不必要的数据冗余，也提高了数据的一致性。")]),_._v(" "),v("li",[_._v("数据结构化，整个数据库按一定的结构形式构成，数据在记录内部和记录类型之间相互关联，用户可通过不同的路径存取数据。")]),_._v(" "),v("li",[_._v("统一的数据保护功能，在多用户共享数据资源的情况下，对用户使用数据有严格的检查，对数据库 规定密码或存取权限，拒绝非法用户进入数据库，以确保数据的安全性、一致性和并发控制。")])]),_._v(" "),v("h3",{attrs:{id:"非关系型数据库和关系型数据库区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#非关系型数据库和关系型数据库区别"}},[_._v("#")]),_._v(" 非关系型数据库和关系型数据库区别")]),_._v(" "),v("h4",{attrs:{id:"关系型数据库"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#关系型数据库"}},[_._v("#")]),_._v(" 关系型数据库:")]),_._v(" "),v("p",[v("strong",[_._v("优点")]),_._v("：二维表格，容易理解。 容易操作。 易于维护。 支持 SQL。")]),_._v(" "),v("p",[_._v("**缺点：**读写性能较差。 固定的表结构，不够灵活。 应对高并发场景，磁盘 I/O 存在瓶颈。 海量数据的读写性 能差。")]),_._v(" "),v("h4",{attrs:{id:"非关系型数据库"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#非关系型数据库"}},[_._v("#")]),_._v(" 非关系型数据库")]),_._v(" "),v("p",[_._v("**优点：**不需要 SQL 解析，读写性能高。 可以使用内存或者硬盘作为载体，速度快。 基于键值对，数据没有耦 合性，方便扩展。 部署简单。")]),_._v(" "),v("p",[_._v("**缺点：**不支持SQL，增加了学习成本。 没有事务。")]),_._v(" "),v("h3",{attrs:{id:"什么是sql"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是sql"}},[_._v("#")]),_._v(" 什么是SQL：")]),_._v(" "),v("p",[v("strong",[_._v("结构化查询语言")]),_._v(" (Structured Query Language) 简称 SQL，是一种特殊目的的编程语言，是一种数据库 查询和程序设计语言程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统")]),_._v(" "),v("h3",{attrs:{id:"mysql和postgreysql的差别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql和postgreysql的差别"}},[_._v("#")]),_._v(" MYSQL和postgreySQl的差别")]),_._v(" "),v("p",[_._v("PG具备更高的可靠性，对数据一致性完整性的支持高于MySQL，因此PG更加适合严格的企业应用场景（比如金融、电信、ERP、CRM）；而MySQL查询速度较快，更加适合业务逻辑相对简单、数据可靠性要求较低的互联网场景（比如google、facebook、alibaba）。")]),_._v(" "),v("h3",{attrs:{id:"mysql的数据类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql的数据类型"}},[_._v("#")]),_._v(" mysql的数据类型")]),_._v(" "),v("p",[_._v("整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT。")]),_._v(" "),v("p",[_._v("浮点数类型：FLOAT（单精度）、DOUBLE（双精度）、DECIMAL。")]),_._v(" "),v("p",[_._v("字符串类型：CHAR（会删除）、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、 BLOB、MEDIUM BLOB、LONG BLOB。")]),_._v(" "),v("p",[_._v("日期类型：Date、DateTime、TimeStamp、Time、Year。")]),_._v(" "),v("p",[_._v("其他数据类型：BINARY、VARBINARY、ENUM、SET...")]),_._v(" "),v("h2",{attrs:{id:"_4-超键、候选键、主键、外键分别是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-超键、候选键、主键、外键分别是什么"}},[_._v("#")]),_._v(" 4. 超键、候选键、主键、外键分别是什么？")]),_._v(" "),v("ul",[v("li",[_._v("超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。")]),_._v(" "),v("li",[_._v("候选键：是最小超键，即没有冗余元素的超键。")]),_._v(" "),v("li",[_._v("主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有 一个主键，且主键的取值不能缺失，即不能为空值（Null）。")]),_._v(" "),v("li",[_._v("外键：在一个表中存在的另一个表的主键称此字段为此表的外键。")])]),_._v(" "),v("h2",{attrs:{id:"_5-sql-约束有哪几种"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-sql-约束有哪几种"}},[_._v("#")]),_._v(" 5 SQL 约束有哪几种")]),_._v(" "),v("ul",[v("li",[_._v("NOT NULL: 用于控制字段的内容一定不能为空（NULL）。")]),_._v(" "),v("li",[_._v("UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。")]),_._v(" "),v("li",[_._v("PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。")]),_._v(" "),v("li",[_._v("FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它 指向的那个表中的值之一。")]),_._v(" "),v("li",[_._v("CHECK: 用于控制字段的值范围。")])]),_._v(" "),v("h2",{attrs:{id:"_6-三个范式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-三个范式"}},[_._v("#")]),_._v(" 6. 三个范式")]),_._v(" "),v("h3",{attrs:{id:"_1范式-1nf"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1范式-1nf"}},[_._v("#")]),_._v(" "),v("strong",[_._v("1范式")]),_._v("：1NF")]),_._v(" "),v("p",[_._v("数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成")]),_._v(" "),v("h3",{attrs:{id:"_2范式-2nf"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2范式-2nf"}},[_._v("#")]),_._v(" "),v("strong",[_._v("2范式")]),_._v("：2NF")]),_._v(" "),v("p",[_._v("在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。**强调依赖性：**要求数据库表中所有非关键字段都完全依赖于任意 一组候选关键字。")]),_._v(" "),v("h3",{attrs:{id:"_3范式-3nf"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3范式-3nf"}},[_._v("#")]),_._v(" "),v("strong",[_._v("3范式")]),_._v("：3NF")]),_._v(" "),v("p",[_._v("满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。")]),_._v(" "),v("p",[_._v("所以第三范式具有如下特征：\n1，每一列只有一个值\n2，每一行都能区分。\n3，每一个表都不包含其他表已经包含的非主关键字信息。")]),_._v(" "),v("p",[v("a",{attrs:{href:"https://blog.csdn.net/weixin_52837751/article/details/116605537",target:"_blank",rel:"noopener noreferrer"}},[_._v("三个范式"),v("OutboundLink")],1)]),_._v(" "),v("h2",{attrs:{id:"_7-什么是子查询"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-什么是子查询"}},[_._v("#")]),_._v(" 7.什么是子查询")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("条件：一条SQL语句的查询结果做为另一条查询语句的条件或查询结果")])]),_._v(" "),v("li",[v("p",[_._v("嵌套：多条SQL语句嵌套使用，内部的SQL查询语句称为子查询。")])])]),_._v(" "),v("h2",{attrs:{id:"_8-连接分为内连接、左连接、右连接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-连接分为内连接、左连接、右连接"}},[_._v("#")]),_._v(" 8. 连接分为内连接、左连接、右连接")]),_._v(" "),v("ul",[v("li",[_._v("内连接是根据某个条件连接两个表共有的数据；")]),_._v(" "),v("li",[_._v("left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录，如果记录不足的话就是null")]),_._v(" "),v("li",[_._v("right join(右连接)返回包括右表中的所有记录和左表中联结字段相等的记录，左表记录不足的地方就是null")])]),_._v(" "),v("h2",{attrs:{id:"_9-存储过程-procedure-和函数-function-区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_9-存储过程-procedure-和函数-function-区别"}},[_._v("#")]),_._v(" 9 存储过程(procedure)和函数(function)区别")]),_._v(" "),v("h3",{attrs:{id:"存储过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#存储过程"}},[_._v("#")]),_._v(" 存储过程")]),_._v(" "),v("p",[_._v("存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据\n库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。")]),_._v(" "),v("p",[v("strong",[_._v("特点")])]),_._v(" "),v("ul",[v("li",[_._v("封装")]),_._v(" "),v("li",[_._v("复用")]),_._v(" "),v("li",[_._v("可以接受参数也可以返回数据")]),_._v(" "),v("li",[_._v("较少网络交互，效率提升")])]),_._v(" "),v("h3",{attrs:{id:"存储函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#存储函数"}},[_._v("#")]),_._v(" 存储函数")]),_._v(" "),v("p",[_._v("存储函数是有返回值的存储过程，存储函数的参数只能是N类型的。具体语法如下：")]),_._v(" "),v("p",[_._v("存储过程和函数是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程和函数可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。")]),_._v(" "),v("h3",{attrs:{id:"相同点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#相同点"}},[_._v("#")]),_._v(" "),v("strong",[_._v("相同点")])]),_._v(" "),v("p",[_._v("存储过程和函数都是为了可重复的执行操作数据库的 SQL 语句的集合。")]),_._v(" "),v("p",[_._v("存储过程和函数都是一次编译后缓存起来，下次使用就直接命中已经编译好的 sql 语句，减少网络 交互提高了效率。")]),_._v(" "),v("h3",{attrs:{id:"不同点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#不同点"}},[_._v("#")]),_._v(" "),v("strong",[_._v("不同点")])]),_._v(" "),v("ul",[v("li",[v("p",[v("strong",[_._v("标识符不同")]),_._v("，函数的标识符是 function，存储过程是 procedure。")])]),_._v(" "),v("li",[v("p",[_._v("存储过程实现的功能要复杂一点，而函数的实现的功能针对性比较强。")])]),_._v(" "),v("li",[v("p",[_._v("函数需要括号包住输入的参数，而且只能返回一个值或者表或者对象，而存储过程可以返回多个参数")])]),_._v(" "),v("li",[v("p",[_._v("函数可以嵌入到sql中使用，可以在select中调用，存储过程则不行")])]),_._v(" "),v("li",[v("p",[_._v("函数不能直接操实体表，只能操作内建表")])]),_._v(" "),v("li",[v("p",[_._v("存储过程在创建时候即在服务器进行了编译，其执行速度比函数快")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("存储函数使用 select 调用，存储过程需要使用 call 调用。")])])])]),_._v(" "),v("h2",{attrs:{id:"_10-drop、truncate、-delete区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_10-drop、truncate、-delete区别"}},[_._v("#")]),_._v(" 10.drop、truncate、 delete区别")]),_._v(" "),v("p",[v("strong",[_._v("相同点：")])]),_._v(" "),v("p",[_._v("truncate和不带where子句的delete,以及drop都会删除表内的数据")]),_._v(" "),v("p",[v("strong",[_._v("不同点：")])]),_._v(" "),v("ul",[v("li",[_._v("truncate会清除表数据并重置id从1开始,delete就只删除记录,drop可以用来删除表或数据库并且将 表所占用的空间全部释放")]),_._v(" "),v("li",[_._v("truncate和delete只删除数据不删除表的结构。drop语句将删除表的结构被依赖的约(constrain),触 发器(trigger),依赖于该表的存储过程/函数将保留,但是变为 invalid 状态。")]),_._v(" "),v("li",[_._v("速度上一般来说: drop> truncate > delete")]),_._v(" "),v("li",[_._v("使用上,想删除部分数据行用 delete，想删除表用 drop,想保留表而将所有数据删除，如果和事务无 关，用truncate即可。如果和事务有关,或者想触发trigger,还是用delete。")]),_._v(" "),v("li",[_._v("delete是DML语句,不会自动提交。drop/truncate都是DDL语句,执行后会自动提交。")])]),_._v(" "),v("h2",{attrs:{id:"_11-关于触发器了解吗尽量说"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_11-关于触发器了解吗尽量说"}},[_._v("#")]),_._v(" 11. 关于触发器了解吗尽量说")]),_._v(" "),v("h3",{attrs:{id:"什么是触发器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是触发器"}},[_._v("#")]),_._v(" 什么是触发器")]),_._v(" "),v("p",[_._v("触发器（trigger）是MySQL提供给程序员和数据分析员来保证数据完整性的一种方法，它是与表事件相关的特殊的存储过程，它的执行不是由程序调用，也不是手工启动，而是由事件来触发，比如当对一个表进行操作（insert，delete， update）时就会激活它执行。简单理解为：触发器是指一段代码，当触发某个事件时，自动执行这些代码。")]),_._v(" "),v("h3",{attrs:{id:"触发器作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#触发器作用"}},[_._v("#")]),_._v(" 触发器作用")]),_._v(" "),v("ul",[v("li",[_._v("可在写入数据表前，强制检验或转换数据。")]),_._v(" "),v("li",[_._v("触发器发生错误时，异动的结果会被撤销。")]),_._v(" "),v("li",[_._v("部分数据库管理系统可以针对数据定义语言（DDL）使用触发器，称为DDL触发器。")]),_._v(" "),v("li",[_._v("可依照特定的情况，替换异动的指令 (INSTEAD OF)。")])]),_._v(" "),v("h3",{attrs:{id:"触发器四要素"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#触发器四要素"}},[_._v("#")]),_._v(" 触发器四要素")]),_._v(" "),v("ul",[v("li",[_._v("监视地点（table）")]),_._v(" "),v("li",[_._v("监视事件（insert、update、delete）")]),_._v(" "),v("li",[_._v("触发时间（after、before）")]),_._v(" "),v("li",[_._v("触发事件（insert、update、delete）")])]),_._v(" "),v("h3",{attrs:{id:"mysql常见的触发器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql常见的触发器"}},[_._v("#")]),_._v(" "),v("code",[_._v("MySQL")]),_._v("常见的触发器")]),_._v(" "),v("ol",[v("li",[_._v("Before Insert")]),_._v(" "),v("li",[_._v("After Insert")]),_._v(" "),v("li",[_._v("Before Update")]),_._v(" "),v("li",[_._v("After Update")]),_._v(" "),v("li",[_._v("Before Delete")]),_._v(" "),v("li",[_._v("After Delete")])]),_._v(" "),v("h3",{attrs:{id:"触发器基本语法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#触发器基本语法"}},[_._v("#")]),_._v(" 触发器基本语法")]),_._v(" "),v("p",[_._v("before/after： 触发器是在增删改之前执行，还是之后执行")]),_._v(" "),v("p",[_._v("delete/insert/update： 触发器由哪些行为触发（增、删、改）")]),_._v(" "),v("p",[_._v("on 表名： 触发器监视哪张表的（增、删、改）操作")]),_._v(" "),v("p",[_._v("触发SQL代码块： 执行触发器包含的SQL语句")]),_._v(" "),v("blockquote",[v("p",[_._v("注意： 触发器也是存储过程程序的一种，而触发器内部的执行SQL语句是可以多行操作的，所以在 MySQL的存储过程程序中，要定义结束符。")])]),_._v(" "),v("h2",{attrs:{id:"_12-mysql中的in和exit的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_12-mysql中的in和exit的区别"}},[_._v("#")]),_._v(" 12. mysql中的in和exit的区别")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("in在查询的时候")]),_._v("，首先查询子查询的表，然后将内表和外表做一个笛卡尔积，然后按照条件进行筛选。所以相对内表比较小的时候，in的速度较快。")]),_._v(" "),v("li",[_._v("exists语句是对外表作loop循环，每次loop循环再对 内表进行查询。")])]),_._v(" "),v("h3",{attrs:{id:"何时使用in以及exit"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#何时使用in以及exit"}},[_._v("#")]),_._v(" 何时使用in以及exit")]),_._v(" "),v("ul",[v("li",[_._v("如果查询的两个表大小相当，那么用in和exists差别不大。")]),_._v(" "),v("li",[_._v("如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in")]),_._v(" "),v("li",[_._v("not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而 not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。")])]),_._v(" "),v("h2",{attrs:{id:"_13-视图"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_13-视图"}},[_._v("#")]),_._v(" 13. 视图")]),_._v(" "),v("p",[_._v("视图是一张虚拟表，是一张逻辑表，是SQL查询的结果集。视图如同真实的数据表一样，包含带有名称的列和行数据，在使用视图时动态生成。通过视图可以展现基表的部分数据。")]),_._v(" "),v("h3",{attrs:{id:"视图的优点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#视图的优点"}},[_._v("#")]),_._v(" 视图的优点：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("简单： 不要关心后边的表结构，关联条件和筛选条件，对用户来说都是过滤好的集合")])]),_._v(" "),v("li",[v("p",[_._v("安全： 使用视图的用户只能访问允许被他们查询的结果集，对表的权限管理并不能限制具体行和列，但通过视图可以简单的实现。")])]),_._v(" "),v("li",[v("p",[_._v("数据独立： 一旦视图的结构确定了，就可以屏蔽表结构变化对用户的影响，基表增加列对视图无影响；基表修改列名，可以通过修改视图来解决，不会造成对访问者的影响。")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);