(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{627:function(v,_,a){"use strict";a.r(_);var e=a(10),t=Object(e.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("p",[v._v("总结Java高并发")]),v._v(" "),a("h2",{attrs:{id:"_1-volatile关键字"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-volatile关键字"}},[v._v("#")]),v._v(" 1. volatile关键字")]),v._v(" "),a("h3",{attrs:{id:"_1-1-jvm缓存模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-jvm缓存模型"}},[v._v("#")]),v._v(" 1.1 JVM缓存模型")]),v._v(" "),a("p",[v._v("当前的 Java 内存模型下，线程可以把变量保存"),a("strong",[v._v("本地内存")]),v._v("（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成"),a("strong",[v._v("数据的不一致")]),v._v("。")]),v._v(" "),a("blockquote",[a("ul",[a("li",[a("strong",[v._v("主内存")]),v._v(" ：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)")]),v._v(" "),a("li",[a("strong",[v._v("本地内存")]),v._v(" ：每个线程都有一个私有的本地内存来存储共享变量的副本，并且，每个线程只能访问自己的本地内存，无法访问其他线程的本地内存。本地内存是 JMM 抽象出来的一个概念，存储了主内存中的共享变量副本。")])])]),v._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/202206292115633.png",alt:"java内存缓存"}})]),v._v(" "),a("p",[v._v("要解决这个问题，就需要把变量声明为 "),a("strong",[a("code",[v._v("volatile")])]),v._v(" ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。")]),v._v(" "),a("p",[v._v("所以，"),a("strong",[a("code",[v._v("volatile")]),v._v(" 关键字 除了防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性。")])]),v._v(" "),a("h3",{attrs:{id:"_1-2-并发编程的三个重要特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-并发编程的三个重要特性"}},[v._v("#")]),v._v(" 1.2 并发编程的三个重要特性")]),v._v(" "),a("ol",[a("li",[a("strong",[v._v("原子性")]),v._v(" : 一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。"),a("code",[v._v("synchronized")]),v._v(" 可以保证代码片段的原子性。")]),v._v(" "),a("li",[a("strong",[v._v("可见性")]),v._v(" ：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。"),a("code",[v._v("volatile")]),v._v(" 关键字可以保证共享变量的可见性。")]),v._v(" "),a("li",[a("strong",[v._v("有序性")]),v._v(" ：代码在执行的过程中的先后顺序，Java在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。"),a("code",[v._v("volatile")]),v._v(" 关键字可以禁止指令进行重排序优化。")])]),v._v(" "),a("h3",{attrs:{id:"_1-3-synchronized-关键字和-volatile-关键字的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-synchronized-关键字和-volatile-关键字的区别"}},[v._v("#")]),v._v(" 1.3 synchronized 关键字和 volatile 关键字的区别")]),v._v(" "),a("p",[a("code",[v._v("synchronized")]),v._v(" 关键字和 "),a("code",[v._v("volatile")]),v._v(" 关键字是两个互补的存在，而不是对立的存在！")]),v._v(" "),a("ul",[a("li",[a("strong",[a("code",[v._v("volatile")]),v._v(" 关键字")]),v._v("是线程同步的"),a("strong",[v._v("轻量级实现")]),v._v("，所以 "),a("strong",[a("code",[v._v("volatile")]),v._v("性能肯定比"),a("code",[v._v("synchronized")]),v._v("关键字要好")]),v._v(" 。但是 "),a("strong",[a("code",[v._v("volatile")]),v._v(" 关键字只能用于变量而 "),a("code",[v._v("synchronized")]),v._v(" 关键字可以修饰方法以及代码块")]),v._v(" 。")]),v._v(" "),a("li",[a("strong",[a("code",[v._v("volatile")]),v._v(" 关键字能保证数据的可见性，但不能保证数据的原子性。"),a("code",[v._v("synchronized")]),v._v(" 关键字两者都能保证。")])]),v._v(" "),a("li",[a("strong",[a("code",[v._v("volatile")]),v._v("关键字主要用于解决变量在多个线程之间的可见性，而 "),a("code",[v._v("synchronized")]),v._v(" 关键字解决的是多个线程之间访问资源的同步性。")])])]),v._v(" "),a("h2",{attrs:{id:"_2-threadlocal"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-threadlocal"}},[v._v("#")]),v._v(" 2. ThreadLocal")]),v._v(" "),a("h3",{attrs:{id:"threadlocal-简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal-简介"}},[v._v("#")]),v._v(" ThreadLocal 简介")]),v._v(" "),a("p",[v._v("通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。"),a("strong",[v._v("如果想实现每一个线程都有自己的专属本地变量该如何解决呢？")]),v._v(" JDK 中提供的"),a("code",[v._v("ThreadLocal")]),v._v("类正是为了解决这样的问题。 "),a("strong",[a("code",[v._v("ThreadLocal")]),v._v("类主要解决的就是让每个线程绑定自己的值，可以将"),a("code",[v._v("ThreadLocal")]),v._v("类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。")])]),v._v(" "),a("p",[a("strong",[v._v("如果你创建了一个"),a("code",[v._v("ThreadLocal")]),v._v("变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是"),a("code",[v._v("ThreadLocal")]),v._v("变量名的由来。他们可以使用 "),a("code",[v._v("get（）")]),v._v(" 和 "),a("code",[v._v("set（）")]),v._v(" 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。")])]),v._v(" "),a("p",[v._v("ThreadLocal 是线程共享变量。ThreadLoacl 有一个静态内部类 ThreadLocalMap，其 Key 是 ThreadLocal 对象，值是 Entry 对象，ThreadLocalMap是每个线程私有的。")]),v._v(" "),a("ul",[a("li",[v._v("set 给ThreadLocalMap设置值。")]),v._v(" "),a("li",[v._v("get 获取ThreadLocalMap。")]),v._v(" "),a("li",[v._v("remove 删除ThreadLocalMap类型的对象。")])]),v._v(" "),a("p",[a("strong",[v._v("存在的问题")])]),v._v(" "),a("ol",[a("li",[a("p",[v._v("对于线程池，由于线程池会重用 Thread 对象，因此与 Thread 绑定的 ThreadLocal 也会被重用， 造成一系列问题。")])]),v._v(" "),a("li",[a("p",[v._v("内存泄漏。由于 ThreadLocal 是弱引用，但 Entry 的 value 是强引用，因此当 ThreadLocal 被垃 圾回收后，value 依旧不会被释放，产生内存泄漏。")])])]),v._v(" "),a("h2",{attrs:{id:"_3-线程池"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-线程池"}},[v._v("#")]),v._v(" 3. 线程池")]),v._v(" "),a("h3",{attrs:{id:"_3-1-为什么要用线程池"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-为什么要用线程池"}},[v._v("#")]),v._v(" 3.1 为什么要用线程池？")]),v._v(" "),a("blockquote",[a("p",[v._v("池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。")])]),v._v(" "),a("p",[v._v("没有线程池的情况下，多次创建，销毁线程开销比较大。如果在开辟的线程执行完当前任务后执行接下 来任务，复用已创建的线程，降低开销、控制最大并发数。")]),v._v(" "),a("p",[v._v("线程池创建线程时，会将线程封装成工作线程 Worker，Worker 在执行完任务后还会循环获取工作队列 中的任务来执行。")]),v._v(" "),a("p",[v._v("将任务派发给线程池时，会出现以下几种情况")]),v._v(" "),a("ol",[a("li",[v._v("核心线程池未满，创建一个新的线程执行任务。")]),v._v(" "),a("li",[v._v("如果核心线程池已满，工作队列未满，将线程存储在工作队列。")]),v._v(" "),a("li",[v._v("如果工作队列已满，线程数小于最大线程数就创建一个新线程处理任务。")]),v._v(" "),a("li",[v._v("如果超过大小线程数，按照拒绝策略来处理任务。")])]),v._v(" "),a("h3",{attrs:{id:"_3-2-线程池参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-线程池参数"}},[v._v("#")]),v._v(" 3.2 线程池参数")]),v._v(" "),a("ol",[a("li",[a("p",[v._v("corePoolSize：常驻核心线程数。超过该值后如果线程空闲会被销毁。")])]),v._v(" "),a("li",[a("p",[v._v("maximumPoolSize：线程池能够容纳同时执行的线程最大数。")])]),v._v(" "),a("li",[a("p",[v._v("keepAliveTime：线程空闲时间，线程空闲时间达到该值后会被销毁，直到只剩下 corePoolSize 个 线程为止，避免浪费内存资源。")])]),v._v(" "),a("li",[a("p",[v._v("workQueue：工作队列。")])]),v._v(" "),a("li",[a("p",[v._v("threadFactory：线程工厂，用来生产一组相同任务的线程。")])]),v._v(" "),a("li",[a("p",[v._v("handler：拒绝策略。有以下几种拒绝策略：")])])]),v._v(" "),a("p",[v._v("AbortPolicy：丢弃任务并抛出异常 CallerRunsPolicy：重新尝试提交该任务 DiscardOldestPolicy 抛弃队列里等待最久的任务并把当前任务加入队列 DiscardPolicy 表示直接抛弃当前任务但不抛出异常。")]),v._v(" "),a("h3",{attrs:{id:"_3-3-线程池的创建方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-线程池的创建方法"}},[v._v("#")]),v._v(" 3.3 线程池的创建方法")]),v._v(" "),a("ol",[a("li",[a("p",[v._v("newCachedThreadPool 可缓存线程池，可设置最小线程数和最大线程数，线程空闲1分钟后自动 销毁。")])]),v._v(" "),a("li",[a("p",[v._v("newFixedThreadPool 指定工作线程数量线程池。")])]),v._v(" "),a("li",[a("p",[v._v("newSingleThreadExecutor 单线程Executor。")])]),v._v(" "),a("li",[a("p",[v._v("newScheduleThreadPool 支持定时任务的指定工作线程数量线程池。")])]),v._v(" "),a("li",[a("p",[v._v("newSingleThreadScheduledExecutor 支持定时任务的单线程Executor。")])])]),v._v(" "),a("h3",{attrs:{id:"_3-4-简述线程池的状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-简述线程池的状态"}},[v._v("#")]),v._v(" 3.4 简述线程池的状态")]),v._v(" "),a("ul",[a("li",[a("code",[v._v("Running")]),v._v("：能接受新提交的任务，也可以处理阻塞队列的任务。")]),v._v(" "),a("li",[a("code",[v._v("Shutdown")]),v._v("：不再接受新提交的任务，但可以处理存量任务，线程池处于running时调用shutdown 方法，会进入该状态。")]),v._v(" "),a("li",[a("code",[v._v("Stop")]),v._v("：不接受新任务，不处理存量任务，调用shutdownnow进入该状态。")]),v._v(" "),a("li",[a("code",[v._v("Tidying")]),v._v("：所有任务已经终止了，worker_count（有效线程数）为0。")]),v._v(" "),a("li",[a("code",[v._v("Terminated")]),v._v("：线程池彻底终止。在tidying模式下调用terminated方法会进入该状态。")])]),v._v(" "),a("h2",{attrs:{id:"_4-atomic-原子类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-atomic-原子类"}},[v._v("#")]),v._v(" 4 Atomic 原子类")]),v._v(" "),a("h3",{attrs:{id:"atomic-原子类概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#atomic-原子类概念"}},[v._v("#")]),v._v(" Atomic 原子类概念")]),v._v(" "),a("p",[a("code",[v._v("Atomic")]),v._v(" 翻译成中文是原子的意思。Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。")]),v._v(" "),a("p",[v._v("所以，所谓原子类说简单点就是具有原子/原子操作特征的类。并发包 "),a("code",[v._v("java.util.concurrent")]),v._v(" 的原子类都存放在"),a("code",[v._v("java.util.concurrent.atomic")]),v._v("下")]),v._v(" "),a("h2",{attrs:{id:"_5-aqs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-aqs"}},[v._v("#")]),v._v(" 5 AQS")]),v._v(" "),a("h3",{attrs:{id:"aqs介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aqs介绍"}},[v._v("#")]),v._v(" AQS介绍")]),v._v(" "),a("p",[v._v("AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出大量应用广泛的同步器，比如我们提到的 "),a("code",[v._v("ReentrantLock")]),v._v("，"),a("code",[v._v("Semaphore")]),v._v("，其他的诸如 "),a("code",[v._v("ReentrantReadWriteLock")]),v._v("，"),a("code",[v._v("SynchronousQueue")]),v._v("，"),a("code",[v._v("FutureTask")]),v._v(" 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。")]),v._v(" "),a("h3",{attrs:{id:"aqs的原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aqs的原理"}},[v._v("#")]),v._v(" AQS的原理")]),v._v(" "),a("p",[v._v("AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。")]),v._v(" "),a("details",{staticClass:"custom-block details"},[a("summary",[v._v("参考文献")]),v._v(" "),a("p",[a("a",{attrs:{href:"https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#synchronized-%E5%85%B3%E9%94%AE%E5%AD%97",target:"_blank",rel:"noopener noreferrer"}},[v._v("并发编程"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);_.default=t.exports}}]);