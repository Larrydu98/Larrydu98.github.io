(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{589:function(e,t,r){"use strict";r.r(t);var s=r(10),a=Object(s.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p",[e._v("总结DockerFile和镜像的发布")]),e._v(" "),r("h2",{attrs:{id:"_1-dockerfile"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-dockerfile"}},[e._v("#")]),e._v(" 1 DockerFile")]),e._v(" "),r("p",[e._v("Dockerfile是用来构建"),r("a",{attrs:{href:"https://so.csdn.net/so/search?q=Docker&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[e._v("Docker"),r("OutboundLink")],1),e._v("镜像的文本文件，也可以说是命令参数脚本。"),r("code",[e._v("docker build")]),e._v("命令用于从Dockerfile构建镜像。可以在"),r("code",[e._v("docker build")]),e._v("命令中使用-f标志指向文件系统中任何位置的Dockerfile。")]),e._v(" "),r("p",[e._v("Docker镜像发布的步骤：\n1、编写一个dockerfile文件")]),e._v(" "),r("p",[e._v("2、docker build 构建成为一个镜像")]),e._v(" "),r("p",[e._v("3、docker run 镜像")]),e._v(" "),r("p",[e._v("4、docker push 镜像（发布镜像到DockerHub、阿里云镜像仓库）")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/202206111616014.png",alt:"Dock而镜像"}})]),e._v(" "),r("h2",{attrs:{id:"_2-dockerfile指令说明"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-dockerfile指令说明"}},[e._v("#")]),e._v(" 2 Dockerfile指令说明")]),e._v(" "),r("table",[r("thead",[r("tr",[r("th",[e._v("指令")]),e._v(" "),r("th",[e._v("说明")])])]),e._v(" "),r("tbody",[r("tr",[r("td",[e._v("FROM")]),e._v(" "),r("td",[e._v("指定基础镜像")])]),e._v(" "),r("tr",[r("td",[e._v("MAINTAINER")]),e._v(" "),r("td",[e._v("镜像是谁写的，姓名+邮箱")])]),e._v(" "),r("tr",[r("td",[e._v("RUN")]),e._v(" "),r("td",[e._v("镜像构建的时候需要运行的命令")])]),e._v(" "),r("tr",[r("td",[e._v("ADD")]),e._v(" "),r("td",[e._v("将本地文件添加到容器中，tar类型文件会自动解压(网络压缩资源不会被解压)，可以访问网络资源，类似wget")])]),e._v(" "),r("tr",[r("td",[e._v("WORKDIR")]),e._v(" "),r("td",[e._v("镜像的工作目录")])]),e._v(" "),r("tr",[r("td",[e._v("VOLUME")]),e._v(" "),r("td",[e._v("挂载的目录")])]),e._v(" "),r("tr",[r("td",[e._v("EXPOSE")]),e._v(" "),r("td",[e._v("保留端口配置")])]),e._v(" "),r("tr",[r("td",[e._v("CMD")]),e._v(" "),r("td",[e._v("指定这个容器启动的时候要运行的命令（只有最后一个会生效）")])]),e._v(" "),r("tr",[r("td",[e._v("EMTRYPOINT")]),e._v(" "),r("td",[e._v("指定这个容器启动的时候要运行的命令，可以追加命令")])]),e._v(" "),r("tr",[r("td",[e._v("ONBUILD")]),e._v(" "),r("td",[e._v("当构建一个被继承DockerFile，这个时候就会运行ONBUILD的指令，触发指令")])]),e._v(" "),r("tr",[r("td",[e._v("COPY")]),e._v(" "),r("td",[e._v("功能类似ADD，但是是不会自动解压文件，也不能访问网络资源")])]),e._v(" "),r("tr",[r("td",[e._v("ENV")]),e._v(" "),r("td",[e._v("构建的时候设置环境变量")])])])]),e._v(" "),r("p",[e._v("一个形象的解释各个指令作用的图：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/202206111619319.png",alt:"指令的图"}})]),e._v(" "),r("h2",{attrs:{id:"_3-制作centos镜像"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-制作centos镜像"}},[e._v("#")]),e._v(" 3 制作Centos镜像")]),e._v(" "),r("p",[e._v("下面通过编写Dockerfile文件来制作Centos镜像，并在官方镜像的基础上添加vim和net-tools工具。首先在/home/dockfile 目录下新建文件mydockerfile-centos。然后使用上述指令编写该文件。")]),e._v(" "),r("div",{staticClass:"language-sh line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-sh"}},[r("code",[r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("root@iZwz99sm8v95sckz8bd2c4Z dockerfile"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# cat mydockerfile-centos")]),e._v("\nFROM centos\nMAINTAINER ethan"),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("1258398543")]),e._v("@qq.com"),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("\n\nENV MYPATH /usr/local\nWORKDIR "),r("span",{pre:!0,attrs:{class:"token variable"}},[e._v("$MYPATH")]),e._v("\n\nRUN yum -y "),r("span",{pre:!0,attrs:{class:"token function"}},[e._v("install")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token function"}},[e._v("vim")]),e._v("\nRUN yum -y "),r("span",{pre:!0,attrs:{class:"token function"}},[e._v("install")]),e._v(" net-tools\n\nEXPOSE "),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("80")]),e._v("\n\nCMD "),r("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("echo")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token variable"}},[e._v("$MYPATH")]),e._v("\nCMD "),r("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("echo")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token string"}},[e._v('"---end---"')]),e._v("\nCMD /bin/bash\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br"),r("span",{staticClass:"line-number"},[e._v("7")]),r("br"),r("span",{staticClass:"line-number"},[e._v("8")]),r("br"),r("span",{staticClass:"line-number"},[e._v("9")]),r("br"),r("span",{staticClass:"line-number"},[e._v("10")]),r("br"),r("span",{staticClass:"line-number"},[e._v("11")]),r("br"),r("span",{staticClass:"line-number"},[e._v("12")]),r("br"),r("span",{staticClass:"line-number"},[e._v("13")]),r("br"),r("span",{staticClass:"line-number"},[e._v("14")]),r("br"),r("span",{staticClass:"line-number"},[e._v("15")]),r("br")])]),r("p",[e._v("通过这个dockerfile构建镜像，构建镜像命令：docker build -f dockerfile文件路径 -t 镜像名[:版本号] .（这里有个小点.）")]),e._v(" "),r("p",[e._v("上面命令中，-t参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是latest。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。")]),e._v(" "),r("p",[e._v("下面执行build命令生成image文件，如果执行成功，可以通过docker images来查看新生成的镜像文件。")]),e._v(" "),r("div",{staticClass:"language-shell line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-shell"}},[r("code",[r("span",{pre:!0,attrs:{class:"token function"}},[e._v("docker")]),e._v(" build -f mydockerfile-centos -t mycentos:1.0 "),r("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v(".")]),e._v("\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br")])]),r("h2",{attrs:{id:"_4-run-cmd和entrypoint的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-run-cmd和entrypoint的区别"}},[e._v("#")]),e._v(" 4 RUN, CMD和ENTRYPOINT的区别")]),e._v(" "),r("p",[e._v("简单说，RUN命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；CMD命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个RUN命令，但是只能有一个CMD命令。")]),e._v(" "),r("h3",{attrs:{id:"cmd和entrypoint的区别在哪里"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cmd和entrypoint的区别在哪里"}},[e._v("#")]),e._v(" "),r("code",[e._v("CMD")]),e._v("和"),r("code",[e._v("ENTRYPOINT")]),e._v("的区别在哪里？")]),e._v(" "),r("ul",[r("li",[e._v("CMD ：指定容器启动的时候要运行的命令，只有最后一个会生效")]),e._v(" "),r("li",[e._v("ENTRYPOINT ：指定容器启动的时候要运行的命令,命令可以追加")])]),e._v(" "),r("h2",{attrs:{id:"_5-docker默认网络模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-docker默认网络模式"}},[e._v("#")]),e._v(" 5 Docker默认网络模式")]),e._v(" "),r("p",[e._v("Docker默认提供了四个网络模式，说明：")]),e._v(" "),r("ol",[r("li",[e._v("bridge：容器默认的网络是桥接模式(自己搭建的网络默认也是使用桥接模式,启动容器默认也是使用桥接模式)。此模式会为每一个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥，通过docker0网桥以及Iptables nat表配置与宿主机通信。")]),e._v(" "),r("li",[e._v("none：不配置网络，容器有独立的Network namespace，但并没有对其进行任何网络设置，如分配veth pair 和网桥连接，配置IP等。")]),e._v(" "),r("li",[e._v("host：容器和宿主机共享Network namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。")]),e._v(" "),r("li",[e._v("container：创建的容器不会创建自己的网卡，配置自己的IP容器网络连通。容器和另外一个容器共享Network namespace（共享IP、端口范围）")])]),e._v(" "),r("p",[e._v("Docker容器默认使用的是Bridge模式，可以通过"),r("code",[e._v("Docker run --network=")]),e._v("来选定容器使用的网络")]),e._v(" "),r("h3",{attrs:{id:"bridge模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#bridge模式"}},[e._v("#")]),e._v(" Bridge模式")]),e._v(" "),r("p",[e._v("当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。")]),e._v(" "),r("p",[e._v("从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。在主机上创建一对虚拟网卡veth pair设备，Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0（容器的网卡），另一端放在主机中，以vethxxx这样类似的名字命名，并将这个网络设备加入到docker0网桥中。可以通过brctl show命令查看。")]),e._v(" "),r("p",[e._v("bridge模式是docker的默认网络模式，不写–net参数，就是bridge模式。使用docker run -p时，docker实际是在iptables做了DNAT规则，实现端口转发功能。可以使用iptables -t nat -vnL查看。bridge模式如下图所示：\n"),r("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/202206111634231.png",alt:"docker网关"}})]),e._v(" "),r("p",[e._v("Docker容器完成bridge网络配置的过程如下：")]),e._v(" "),r("p",[e._v("在主机上创建一对虚拟网卡veth pair设备。veth设备总是成对出现的，它们组成了一个数据的通道，数据从一个设备进入，就会从另一个设备出来。因此，veth设备常用来连接两个网络设备。\nDocker将veth pair设备的一端放在新创建的容器中，并命名为eth0。另一端放在主机中，以veth65f9这样类似的名字命名，并将这个网络设备加入到docker0网桥中。\n从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。")]),e._v(" "),r("h2",{attrs:{id:"_6-docker-compose"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-docker-compose"}},[e._v("#")]),e._v(" 6 Docker-compose")]),e._v(" "),r("p",[e._v("Docker Compose是一个用来定义和运行复杂应用的Docker工具。一个使用Docker容器的应用，通常由多个容器组成。使用Docker Compose不再需要使用shell脚本来启动容器。\nCompose 通过一个配置文件来管理多个Docker容器，在配置文件中，所有的容器通过services来定义，然后使用docker-compose脚本来启动，停止和重启应用，和应用中的服务以及所有依赖服务的容器，非常适合组合使用多个容器进行开发的场景。\n"),r("a",{attrs:{href:"https://blog.csdn.net/pushiqiang/article/details/78682323",target:"_blank",rel:"noopener noreferrer"}},[e._v("docker-compose详解"),r("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=a.exports}}]);