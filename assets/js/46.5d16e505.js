(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{633:function(t,_,v){"use strict";v.r(_);var a=v(10),r=Object(a.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"_1-什么是http协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是http协议"}},[t._v("#")]),t._v(" 1. 什么是HTTP协议？")]),t._v(" "),v("p",[t._v("HTTP（超文本传输协议，"),v("code",[t._v("HyperText Transfer Protocol")]),t._v("）是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。"),v("em",[t._v("通常所指代的http就是"),v("strong",[t._v("http（1.1")]),t._v("）")])]),t._v(" "),v("h3",{attrs:{id:"http优点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http优点"}},[t._v("#")]),t._v(" http优点")]),t._v(" "),v("p",[t._v("HTTP 最凸出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」。")]),t._v(" "),v("ul",[v("li",[v("p",[v("em",[t._v("简单")])]),t._v(" "),v("p",[t._v("HTTP 基本的报文格式就是 "),v("code",[t._v("header + body")]),t._v("，头部信息也是 "),v("code",[t._v("key-value")]),t._v(" 简单文本的形式，"),v("strong",[t._v("易于理解")]),t._v("，降低了学习和使用的门槛。")])]),t._v(" "),v("li",[v("p",[t._v("灵活和易于扩展")]),t._v(" "),v("p",[t._v("HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员"),v("strong",[t._v("自定义和扩充")]),t._v("。")])]),t._v(" "),v("li",[v("p",[t._v("应用广泛和跨平台")]),t._v(" "),v("p",[t._v("互联网发展至今，HTTP 的应用范围非常的广泛，从台式机的浏览器到手机上的各种 APP，从看新闻、刷贴吧到购物、理财、吃鸡，HTTP 的应用遍地开花，同时天然具有"),v("strong",[t._v("跨平台")]),t._v("的优越性。")])])]),t._v(" "),v("h3",{attrs:{id:"http的缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http的缺点"}},[t._v("#")]),t._v(" http的缺点")]),t._v(" "),v("ol",[v("li",[t._v("HTTP 协议里有优缺点一体的"),v("strong",[t._v("双刃剑")]),t._v("，分别是「无状态、明文传输」，同时还有一大缺点「不安全」。")])]),t._v(" "),v("ul",[v("li",[v("p",[t._v("无状态的"),v("strong",[t._v("好处")])]),t._v(" "),v("p",[t._v("因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。")])]),t._v(" "),v("li",[v("p",[t._v("无状态的坏处")]),t._v(" "),v("p",[t._v("既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。")]),t._v(" "),v("p",[t._v("例如登录->添加购物车->下单->结算->支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。")]),t._v(" "),v("p",[t._v("但是引入cookie技术得以解决")])])]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[v("em",[t._v("明文传输双刃剑")]),t._v("明文意味着在传输过程中的信息，是可方便阅读的，为调试带来极大的便利性，但是内容明文传输容易被窃取")]),t._v(" "),v("li",[v("em",[t._v("不安全")])])]),t._v(" "),v("ul",[v("li",[t._v("通信使用明文（不加密），内容可能会被窃听。比如，"),v("strong",[t._v("账号信息容易泄漏，那你号没了。")])]),t._v(" "),v("li",[t._v("不验证通信方的身份，因此有可能遭遇伪装。比如，"),v("strong",[t._v("访问假的淘宝、拼多多，那你钱没了。")])]),t._v(" "),v("li",[t._v("无法证明报文的完整性，所以有可能已遭篡改。比如，"),v("strong",[t._v("网页上植入垃圾广告，视觉污染，眼没了。")])])]),t._v(" "),v("h2",{attrs:{id:"_2-http-的请求方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-http-的请求方法"}},[t._v("#")]),t._v(" 2. HTTP 的请求方法？")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("方法")]),t._v(" "),v("th",[t._v("概述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("GET（获取资源 ）")]),t._v(" "),v("td",[t._v("用于从指定资源请求数据")])]),t._v(" "),v("tr",[v("td",[t._v("POST新增资源")]),t._v(" "),v("td",[t._v("用于将数据发送到服务器来创建/更新资源PUT用于将数据发送到服务器来创建/更新资源 ，POST 和 PUT之间的区别在于 PUT 请求是幂等的（idempotent）。也就是说，多次调用相同的 PUT 请求将始终产生相同的结果。相反，重复调用POST请求具有多次创建相同资源的副作用。")])]),t._v(" "),v("tr",[v("td",[t._v("HEAD（获取HEAD元数据 ）")]),t._v(" "),v("td",[t._v("本质和get一样，但是响应中没有呈现数据，而是http的头信息，主要用来检查资源或超链接的有效性或是否可以可达、检查网页是否被串改或更新，获取头信息等，特别适用在有限的速度和带宽下。")])]),t._v(" "),v("tr",[v("td",[t._v("DELETE"),v("br"),t._v("（删除资源）")]),t._v(" "),v("td",[t._v("删除指定的资源")])]),t._v(" "),v("tr",[v("td",[t._v("OPTIONS"),v("br"),t._v("（获取服务器支持访问资源的方法 ）")]),t._v(" "),v("td",[t._v("获取http服务器支持的http请求方法，允许客户端查看服务器的性能，比如ajax跨域时的预检等。")])]),t._v(" "),v("tr",[v("td",[t._v("CONNECT"),v("br"),t._v("（建立 Tunnel 隧道）")]),t._v(" "),v("td",[t._v("HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。就是把服务器作为跳板，去访问其他网页然后把数据返回回来，连接成功后，就可以正常的get、post了。")])]),t._v(" "),v("tr",[v("td",[t._v("TRACE"),v("br"),t._v("（回显服务器收到的请求，可以定位问题）")]),t._v(" "),v("td",[t._v("回显服务器收到的请求，主要用于测试或诊断。一般禁用，防止被恶意攻击或盗取信息")])])])]),t._v(" "),v("h3",{attrs:{id:"get和post"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#get和post"}},[t._v("#")]),t._v(" GET和POST")]),t._v(" "),v("h3",{attrs:{id:"相同点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#相同点"}},[t._v("#")]),t._v(" "),v("strong",[t._v("相同点")])]),t._v(" "),v("p",[t._v("本质都是TCP/IP协议的一个子协议")]),t._v(" "),v("h3",{attrs:{id:"get和post不同点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#get和post不同点"}},[t._v("#")]),t._v(" GET和POST不同点")]),t._v(" "),v("ul",[v("li",[t._v("GET在浏览器回退时是无害的，而POST会再次提交请求。")]),t._v(" "),v("li",[t._v("GET产生的URL地址可以被书签收藏，而POST不可以。")]),t._v(" "),v("li",[t._v("GET请求会被浏览器主动cache，而POST不会，除非手动设置。")]),t._v(" "),v("li",[t._v("GET请求只能进行url编码（application/x-www-form-urlencoded），而POST支持多种编码方式")])]),t._v(" "),v("p",[t._v("（application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多种编码。）。")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。")])]),t._v(" "),v("li",[v("p",[t._v("GET请求在URL中传送的参数是有长度限制的（因为浏览器对URL的长度有限制，最大长度是 2048 个字符），而POST没有。")])]),t._v(" "),v("li",[v("p",[t._v("对参数的数据类型，GET只接受ASCII字符，而POST没有限制（允许二进制数据）。")])]),t._v(" "),v("li",[v("p",[t._v("GET参数通过URL传递，参数之间以&相连，POST放在Request body中，所以GET请求不安全，敏感信息会暴露在url上。")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("GET和POST还有一个重大区别是发送数据包数量不同")]),t._v("，GET 请求产生一个 TCP 数据包，而POST请求产生两个TCP 数据包，")]),t._v(" "),v("p",[t._v("1、对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；")]),t._v(" "),v("p",[t._v("2、而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。。")])])]),t._v(" "),v("h2",{attrs:{id:"_3-http-0-9、http-1-0、http-1-1、http-2、http-3各版本之间的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-http-0-9、http-1-0、http-1-1、http-2、http-3各版本之间的区别"}},[t._v("#")]),t._v(" 3. HTTP/0.9、HTTP/1.0、HTTP/1.1、HTTP/2、HTTP/3各版本之间的区别？")]),t._v(" "),v("h3",{attrs:{id:"_3-1-http-0-9"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-http-0-9"}},[t._v("#")]),t._v(" 3.1 HTTP/0.9")]),t._v(" "),v("p",[v("code",[t._v("HTTP/0.9")]),t._v("当时是为了学术交流，基于请求和响应的模式，在网络中传输HTML超文本的内容。当时由于都是HTML格式的文件，因此是通过"),v("code",[t._v("ACCII")]),t._v("字符刘进行传输的")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("只有一个请求行，并没有 HTTP 请求头和请求体")])]),t._v(" "),v("li",[v("strong",[t._v("服务器也没有返回头信息")])]),t._v(" "),v("li",[v("strong",[t._v("返回的文件内容是以 ASCII 字符流来传输的")])])]),t._v(" "),v("h3",{attrs:{id:"_3-2-http-1-0"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-http-1-0"}},[t._v("#")]),t._v(" 3.2 HTTP/1.0")]),t._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/202205011550190.png",alt:"02"}}),t._v(" "),v("ul",[v("li",[v("p",[v("strong",[t._v("第一个：支持多种类型、格式、编码、语言的文件，添加请求头和响应头")])]),t._v(" "),v("p",[t._v("请求头的信息告诉服务器浏览器期望返回的数据的类型、压缩格式、编码类型、语言类型，响应头告诉浏览器我当前返回的数据类型、压缩格式、编码类型、语言类型，因为可能浏览器需要的服务器做不到")]),t._v(" "),v("div",{staticClass:"language-js line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-js"}},[v("code",[v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//请求头")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("accept")]),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" text"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("html"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\naccept"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("encoding"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" gzip"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" deflate"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" br"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\naccept"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Charset"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token constant"}},[t._v("ISO")]),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("8859")]),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("utf"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\naccept"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("language"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" zh"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),v("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CN")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("zh"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br"),v("span",{staticClass:"line-number"},[t._v("5")]),v("br")])]),v("div",{staticClass:"language-js line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-js"}},[v("code",[v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//响应头")]),t._v("\ncontent"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("encoding"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" brcontent"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("type"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" text"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("html"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" charset"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),v("span",{pre:!0,attrs:{class:"token constant"}},[t._v("UTF")]),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),t._v("\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br")])])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("引入了状态码。状态码是通过响应行的方式来通知浏览器的。")])])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("为了减轻服务器的压力，在 HTTP/1.0 中提供了 Cache 机制，用来缓存已经下载过的数据。")])])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("服务器需要统计客户端的基础信息，比如 Windows 和 macOS 的用户数量分别是多少，所以 HTTP/1.0 的请求头中还加入了用户代理的字段。")])])])]),t._v(" "),v("h3",{attrs:{id:"_3-3-http-1-1"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-http-1-1"}},[t._v("#")]),t._v(" 3.3 http 1.1")]),t._v(" "),v("ul",[v("li",[v("p",[v("strong",[t._v("tcp持久连接，多个http请求可以在同一个tcp连接上进行。只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持。")])]),t._v(" "),v("p",[t._v("持久连接在 HTTP/1.1 中是默认开启的Connection: keep-alive，所以你不需要专门为了持久连接去 HTTP 请求头设置信息，如果你不想要采用持久连接，可以在 HTTP 请求头中加上Connection: close。目前浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接。")])])]),t._v(" "),v("p",[t._v("​\t"),v("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/202205011703710.png",alt:"03"}})]),t._v(" "),v("ul",[v("li",[v("p",[v("strong",[t._v("管道网络传输，解决了请求的队头阻塞，但是没有解决响应的队头阻塞")])]),t._v(" "),v("p",[t._v("即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。但是"),v("strong",[t._v("服务器必须按照接收请求的顺序发送对这些管道化请求的响应")]),t._v("。")])])]),t._v(" "),v("p",[t._v("​\t"),v("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/202205011704759.png",alt:"04"}})]),t._v(" "),v("ul",[v("li",[v("p",[v("strong",[t._v("提供虚拟主机的支持，HTTP/1.1 的请求头中增加了 Host 字段，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。")])]),t._v(" "),v("p",[t._v("目的是在 HTTP/1.0 中，每个域名绑定了一个唯一的 IP 地址，因此一个服务器只能支持一个域名。但是随着虚拟主机技术的发展，需要实现在一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己的单独的域名，这些单独的域名都公用同一个 IP 地址。因此，就需要请求头中增加host字段，让服务器知道对应的是哪个虚拟机")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("对动态生成的内容(文件大小未知)提供了支持，HTTP/1.1 引入 Chunk transfer 机制，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。")])]),t._v(" "),v("p",[t._v("目的是在设计 HTTP/1.0 时，需要在响应头中设置完整的数据大小，如Content-Length: 901，这样浏览器就可以根据设置的数据大小来接收数据。不过随着服务器端的技术发展，很多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，导致了浏览器不知道何时会接收完所有的文件数据。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("第五个：HTTP/1.1 还引入了客户端 Cookie 机制")]),t._v("（用在登录上的常用的存储）")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("第六个：补充了缓存的请求头和响应头")])])])]),t._v(" "),v("h4",{attrs:{id:"不足"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#不足"}},[t._v("#")]),t._v(" 不足：")]),t._v(" "),v("ul",[v("li",[t._v("请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 "),v("code",[t._v("Body")]),t._v(" 的部分；")]),t._v(" "),v("li",[t._v("发送冗长的首部。每次互相发送相同的首部造成的浪费较多；")]),t._v(" "),v("li",[t._v("服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；")]),t._v(" "),v("li",[t._v("没有请求优先级控制；")]),t._v(" "),v("li",[t._v("请求只能从客户端开始，服务器只能被动响应。")])]),t._v(" "),v("h3",{attrs:{id:"_3-4-http2-0-特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-http2-0-特性"}},[t._v("#")]),t._v(" 3.4 http2.0 特性")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/202205251619472.png",alt:"http比较"}})]),t._v(" "),v("ol",[v("li",[v("p",[v("strong",[t._v("多路复用")])]),t._v(" "),v("p",[t._v("HTTP/2 是可以在"),v("strong",[t._v("一个连接中并发多个请求或回应，而不用按照顺序一一对应")]),t._v("。")]),t._v(" "),v("p",[t._v("移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，"),v("strong",[t._v("降低了延迟，大幅度提高了连接的利用率")]),t._v("。")]),t._v(" "),v("p",[t._v("例子:举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/202205251615927.png",alt:"多路复用"}})])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("数据流")])]),t._v(" "),v("p",[t._v("HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。")]),t._v(" "),v("p",[t._v("在 HTTP/2 中每个请求或相应的所有数据包，称为一个数据流（"),v("code",[t._v("Stream")]),t._v("）。每个数据流都标记着一个独一无二的编号（Stream ID），"),v("strong",[t._v("不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ）")]),t._v("，因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息")]),t._v(" "),v("p",[t._v("客户端和服务器"),v("strong",[t._v("双方都可以建立 Stream")]),t._v("， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/202205251626751.png",alt:"数据流"}})]),t._v(" "),v("p",[t._v("客户端还可以"),v("strong",[t._v("指定数据流的优先级")]),t._v("。优先级高的请求，服务器就先响应该请求")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("服务器推送")])]),t._v(" "),v("p",[t._v("HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以"),v("strong",[t._v("主动")]),t._v("向客户端发送消息。")]),t._v(" "),v("p",[t._v("例子：客户端通过 HTTP/1.1 请求从服务器那获取到了 HTML 文件，而 HTML 可能还需要依赖 CSS 来渲染页面，这时客户端还要再发起获取 CSS 文件的请求，需要两次消息往返，如下图左边部分：")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/202205251616181.png",alt:"服务器推送"}})])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("头部压缩")])]),t._v(" "),v("p",[t._v("如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你"),v("strong",[t._v("消除重复的部分")]),t._v("。")]),t._v(" "),v("p",[t._v("这就是所谓的 "),v("code",[t._v("HPACK")]),t._v(" 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就"),v("strong",[t._v("提高速度")]),t._v("了。")])]),t._v(" "),v("li",[v("p",[t._v("二进制格式")]),t._v(" "),v("p",[t._v("HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了"),v("strong",[t._v("二进制格式")]),t._v("，头信息和数据体都是二进制，并且统称为帧（frame）："),v("strong",[t._v("头信息帧（Headers Frame）和数据帧（Data Frame）")]),t._v("。从而"),v("strong",[t._v("增加了数据传输的效率")]),t._v("。")])])]),t._v(" "),v("h3",{attrs:{id:"http-2-有什么缺陷"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-2-有什么缺陷"}},[t._v("#")]),t._v(" HTTP/2 有什么缺陷？")]),t._v(" "),v("p",[t._v("HTTP/2 通过 Stream 的并发能力，解决了 HTTP/1 队头阻塞的问题，看似很完美了，但是 HTTP/2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而是在 TCP 这一层。")]),t._v(" "),v("p",[t._v("一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的"),v("strong",[t._v("所有的 HTTP 请求都必须等待这个丢了的包被重传回来")]),t._v("。")]),t._v(" "),v("h2",{attrs:{id:"_4-http3-0"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-http3-0"}},[t._v("#")]),t._v(" 4. HTTP3.0")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/202206011639962.png",alt:"http2.0不足"}})]),t._v(" "),v("p",[t._v("前面我们知道了 HTTP/1.1 和 HTTP/2 都有队头阻塞的问题：")]),t._v(" "),v("ul",[v("li",[t._v("HTTP/1.1 中的管道（ pipeline）虽然解决了请求的队头阻塞，但是"),v("strong",[t._v("没有解决响应的队头阻塞")]),t._v("，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等相应完这个请求后， 才能处理下一个请求，这属于 HTTP 层队头阻塞。")]),t._v(" "),v("li",[t._v("HTTP/2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是"),v("strong",[t._v("一旦发生丢包，就会阻塞住所有的 HTTP 请求")]),t._v("，这属于 TCP 层队头阻塞。")])]),t._v(" "),v("p",[t._v("HTTP/2 队头阻塞的问题是因为 TCP，所以 "),v("strong",[t._v("HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/202205251623041.png",alt:"http3.0"}})]),t._v(" "),v("p",[t._v("UDP 发生是不管顺序，也不管丢包的，所以不会出现像 HTTP/2 队头阻塞的问题")]),t._v(" "),v("p",[t._v("大家都知道 UDP 是不可靠传输的，但基于 UDP 的 "),v("strong",[t._v("QUIC 协议")]),t._v(" 可以实现类似 TCP 的可靠性传输。")]),t._v(" "),v("h3",{attrs:{id:"quic协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#quic协议"}},[t._v("#")]),t._v(" QUIC协议")]),t._v(" "),v("p",[v("code",[t._v("HTTP/3")]),t._v(" 选择了一个折衷的方法——UDP 协议，"),v("strong",[t._v("基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能，我们把这套功能称为QUIC 协议")]),t._v("。")]),t._v(" "),v("ul",[v("li",[v("p",[v("em",[v("strong",[t._v("无队头阻塞")])])]),t._v(" "),v("p",[t._v("QUIC 协议也有类似 HTTP/2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。")]),t._v(" "),v("p",[t._v("QUIC 有自己的一套机制可以保证传输的可靠性的。"),v("strong",[t._v("当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题")]),t._v("。这与 HTTP/2 不同，HTTP/2 只要某个流中的数据包丢失了，其他流也会因此受影响。")]),t._v(" "),v("p",[v("strong",[t._v("所以，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。")])])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("更快的建立连接")])]),t._v(" "),v("p",[t._v("对于 HTTP/1 和 HTTP/2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。")]),t._v(" "),v("p",[t._v("HTTP/3 在传输数据前虽然需要 QUIC 协议握手，这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。")]),t._v(" "),v("p",[t._v("但是 HTTP/3 的 QUIC 协议并不是与 TLS 分层，而是QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS/1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，如下图：")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/202205251658244.png",alt:"建立连接"}})])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("连接迁移")])]),t._v(" "),v("p",[t._v("基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接，那么"),v("strong",[t._v("当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接")]),t._v("。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。")]),t._v(" "),v("p",[t._v("而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过"),v("strong",[t._v("连接 ID")]),t._v("来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了"),v("strong",[t._v("连接迁移")]),t._v("的功能。")]),t._v(" "),v("p",[t._v("所以， QUIC 是一个在 UDP 之上的"),v("strong",[t._v("伪")]),t._v(" TCP + TLS + HTTP/2 的多路复用的协议。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/202205251659560.jpg",alt:"连接迁移"}})])])]),t._v(" "),v("h2",{attrs:{id:"_5-http状态码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-http状态码"}},[t._v("#")]),t._v(" 5. HTTP状态码")]),t._v(" "),v("h4",{attrs:{id:"常见状态码区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常见状态码区别"}},[t._v("#")]),t._v(" 常见状态码区别")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("1**")]),t._v(" "),v("th",[t._v("提示信息，表示目前是协议处理的中间状态，还需要后续的操作")]),t._v(" "),v("th")])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("2**")]),t._v(" "),v("td",[t._v("成功，报文已经收到并正确处理")]),t._v(" "),v("td",[t._v("200（成功） 204（成功但响应头无数据） 206（响应返回body只是一部分。）")])]),t._v(" "),v("tr",[v("td",[t._v("3**")]),t._v(" "),v("td",[t._v("重定向，资源位置发生变动，需要客户端重新发送请求")]),t._v(" "),v("td",[t._v("301：永远重定向需要新的URL，响应字段含有location，表示后续跳转的路径； 302：临时重定向，说明请求的资源还在，但暂时需要⽤另⼀个 URL 来访问，同样含有location； 304：缓存重定向，不具有跳转，直接访问缓存（"),v("strong",[t._v("和协商缓存有特别大作用")]),t._v("）")])]),t._v(" "),v("tr",[v("td",[t._v("4**")]),t._v(" "),v("td",[t._v("客户端错误，请求报文有误，服务器无法处理")]),t._v(" "),v("td",[t._v("400：表示客户端请求的报⽂有错误，但只是个笼统的错误； <br / 403；表示服务器禁⽌访问资源，并不是客户端的请求出错， 404：表示请求的资源在服务器上不存在或未找到；")])]),t._v(" "),v("tr",[v("td",[t._v("5**")]),t._v(" "),v("td",[t._v("服务器错误，服务器子处理请求时候发生内部错误")]),t._v(" "),v("td",[t._v("500：服务器发生错误，较为笼统， 501：客户端请求的功能还不⽀持，类似“即将开业，敬请期待”； 502：服务器作为⽹关或代理时返回的错误码，自身正常，方位后端服务器出错； 503：网络正忙，稍后尝试")])])])]),t._v(" "),v("h2",{attrs:{id:"_6-http请求头和响应头"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-http请求头和响应头"}},[t._v("#")]),t._v(" 6. http请求头和响应头")]),t._v(" "),v("h3",{attrs:{id:"_6-1-常用的http请求头"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-常用的http请求头"}},[t._v("#")]),t._v(" 6.1 常用的http请求头")]),t._v(" "),v("p",[t._v("​    "),v("strong",[t._v("1. Accept")])]),t._v(" "),v("p",[t._v("​      Accept: text/html 浏览器可以"),v("strong",[t._v("接受服务器回发的类型为")]),t._v(" text/html。")]),t._v(" "),v("p",[t._v("​      Accept: "),v("em",[t._v("/")]),t._v(" 代表浏览器可以处理所有类型,(一般浏览器发给服务器都是发这个)。")]),t._v(" "),v("p",[t._v("​    "),v("strong",[t._v("2. Accept-Encoding")])]),t._v(" "),v("p",[t._v("​\tAccept-Encoding: gzip, deflate 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）。")]),t._v(" "),v("p",[t._v("​    "),v("strong",[t._v("3. Accept-Language")])]),t._v(" "),v("p",[t._v("​       **Accept-Language:zh-CN,zh;q=0.9 ** 浏览器申明自己接收的语言。")]),t._v(" "),v("p",[t._v("​    "),v("strong",[t._v("4. Connection")])]),t._v(" "),v("p",[t._v("​      Connection: "),v("strong",[t._v("keep-alive")]),t._v(" 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。")]),t._v(" "),v("p",[t._v("​      Connection: "),v("strong",[t._v("close")]),t._v(" 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。")]),t._v(" "),v("p",[t._v("​    "),v("strong",[t._v("5. Host（发送请求时，该报头域是必需的）")]),t._v("（HTTP1.1加的）")]),t._v(" "),v("p",[t._v("​      Host:www.baidu.com 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的。")]),t._v(" "),v("p",[t._v("​    "),v("strong",[t._v("6. User-Agent")])]),t._v(" "),v("p",[t._v("​      User-Agent:Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36 告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本。")]),t._v(" "),v("p",[t._v("​      "),v("strong",[t._v("服务端拿到该信息就可以统计用户访问时使用的设备")])]),t._v(" "),v("p",[t._v("​    "),v("strong",[t._v("7. Cookie")])]),t._v(" "),v("p",[t._v("​      Cookie是用来存储一些用户信息以便让服务器辨别用户身份的（大多数需要登录的网站上面会比较常见），比如cookie会存储一些用户的用户名和密码，当用户登录后就会在客户端产生一个cookie来存储相关信息，这样浏览器通过读取cookie的信息去服务器上验证并通过后会判定你是合法用户，从而允许查看相应网页。当然cookie里面的数据不仅仅是上述范围，还有很多信息可以存储是cookie里面，比如sessionid等。")]),t._v(" "),v("p",[t._v("​    "),v("strong",[t._v("8. content-type")]),t._v(": 发送数据的格式，如：application/json  get请求一般没有")]),t._v(" "),v("h3",{attrs:{id:"_6-2-常见响应头"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-常见响应头"}},[t._v("#")]),t._v(" 6.2 常见响应头")]),t._v(" "),v("h4",{attrs:{id:"缓存相关"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存相关"}},[t._v("#")]),t._v(" 缓存相关")]),t._v(" "),v("p",[v("strong",[t._v("1.Cache-Control（对应请求中的Cache-Control，作为缓存用的）")])]),t._v(" "),v("p",[t._v("​      Cache-Control:private 默认为private 响应只能够作为私有的缓存，不能再用户间共享")]),t._v(" "),v("p",[t._v("​      Cache-Control:public 浏览器和缓存服务器都可以缓存页面信息。")]),t._v(" "),v("p",[t._v("​      Cache-Control:must-revalidate 对于客户机的每次请求，代理服务器必须想服务器验证缓存是否过时。")]),t._v(" "),v("p",[t._v("​      "),v("strong",[t._v("Cache-Control:no-cache 浏览器和缓存服务器都不应该缓存页面信息。")])]),t._v(" "),v("p",[t._v("​      Cache-Control:max-age=10 是通知浏览器10秒之内不要烦我，自己从缓冲区中刷新。")]),t._v(" "),v("p",[t._v("​      Cache-Control:no-store 请求和响应的信息都不应该被存储在对方的磁盘系统中。")]),t._v(" "),v("p",[t._v("​    "),v("strong",[t._v("2.Last-Modified")])]),t._v(" "),v("p",[t._v("​      Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT 所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示)")]),t._v(" "),v("p",[t._v("​    "),v("strong",[t._v("3.Etag")])]),t._v(" "),v("p",[t._v('​      ETag: "737060cd8c284d8af7ad3082f209582d" 就是一个对象（比如URL）的标志值，就一个对象而言，比如一个html文件，如果被修改了，其Etag也会别修改，所以，ETag的作用跟Last-Modified的作用差不多，主要供WEB服务器判断一个对象是否改变了。比如前一次请求某个html文件时，获得了其 ETag，当这次又请求这个文件时，浏览器就会把先前获得ETag值发送给WEB服务器，然后WEB服务器会把这个ETag跟该文件的当前ETag进行对比，然后就知道这个文件有没有改变了。')]),t._v(" "),v("p",[t._v("​    "),v("strong",[t._v("4.Content-Type")])]),t._v(" "),v("p",[t._v("​      Content-Type：text/html;charset=UTF-8 告诉客户端，资源文件的类型，还有字符编码，客户端通过utf-8对资源进行解码，然后对资源进行html解析。通常我们会看到有些网站是乱码的，往往就是服务器端没有返回正确的编码。")]),t._v(" "),v("p",[t._v("​    "),v("strong",[t._v("5.Content-Encoding")])]),t._v(" "),v("p",[t._v("​      Content-Encoding:gzip 告诉客户端，服务端发送的资源是采用gzip编码的，客户端看到这个信息后，应该采用gzip对资源进行解码。")]),t._v(" "),v("p",[t._v("​    "),v("strong",[t._v("6.Date")])]),t._v(" "),v("p",[t._v("​       Date: Tue, 03 Apr 2018 03:52:28 GMT 这个是服务端发送资源时的服务器时间，GMT是格林尼治所在地的标准时间。http协议中发送的时间都是GMT的，这主要是解决在互联网上，不同时区在相互请求资源的时候，时间混乱问题。")]),t._v(" "),v("p",[t._v("​    "),v("strong",[t._v("7.Server")])]),t._v(" "),v("p",[t._v("​      Server：Tengine/1.4.6 这个是服务器和相对应的版本，只是告诉客户端服务器信息**。**")]),t._v(" "),v("p",[v("strong",[t._v("8.Expires")])]),t._v(" "),v("p",[t._v("​      Expires:Sun, 1 Jan 2000 01:00:00 GMT 这个响应头也是跟缓存有关的，告诉客户端在这个时间前，可以直接访问缓存副本，很显然这个值会存在问题，因为客户端和服务器的时间不一定会都是相同的，如果时间不同就会导致问题。所以这个响应头是没有Cache-Control：max-age=*这个响应头准确的，因为max-age=date中的date是个相对时间，不仅更好理解，也更准确。")]),t._v(" "),v("h4",{attrs:{id:"长链接相关"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#长链接相关"}},[t._v("#")]),t._v(" 长链接相关")]),t._v(" "),v("p",[t._v("​    "),v("strong",[t._v("9.Connection")])]),t._v(" "),v("p",[t._v("​      Connection：keep-alive 这个字段作为回应客户端的Connection：keep-alive，告诉客户端服务器的tcp连接也是一个长连接，客户端可以继续使用这个tcp连接发送http请求。")]),t._v(" "),v("h4",{attrs:{id:"跨域相关"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#跨域相关"}},[t._v("#")]),t._v(" 跨域相关")]),t._v(" "),v("p",[t._v("​    "),v("strong",[t._v("10.Access-Control-Allow-Origin")])]),t._v(" "),v("p",[t._v("​      **Access-Control-Allow-Origin: * **  "),v("em",[t._v("号代表所有网站可以跨域资源共享，如果当前字段为")]),t._v("那么Access-Control-Allow-Credentials就不能为true")]),t._v(" "),v("p",[t._v("​      Access-Control-Allow-Origin: www.baidu.com 指定哪些网站可以跨域资源共享")]),t._v(" "),v("p",[t._v("​    "),v("strong",[t._v("11.Access-Control-Allow-Methods")])]),t._v(" "),v("p",[t._v("​      Access-Control-Allow-Methods：GET,POST,PUT,DELETE 允许哪些方法来访问")]),t._v(" "),v("p",[t._v("​    "),v("strong",[t._v("12.Access-Control-Allow-Credentials")])]),t._v(" "),v("p",[t._v("​      Access-Control-Allow-Credentials: true 是否允许发送cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。如果access-control-allow-origin为*，当前字段就不能为true")]),t._v(" "),v("h2",{attrs:{id:"_7-http缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-http缓存"}},[t._v("#")]),t._v(" 7.http缓存")]),t._v(" "),v("p",[v("RouterLink",{attrs:{to:"/blogs/Http/URL的输入到浏览器解析的一系列事件.html"}},[t._v("详情")])],1),t._v(" "),v("h3",{attrs:{id:"_7-1-http缓存的作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-http缓存的作用"}},[t._v("#")]),t._v(" 7.1 http缓存的作用")]),t._v(" "),v("ul",[v("li",[t._v("减少了冗余的数据传递，节省宽带流量")]),t._v(" "),v("li",[t._v("减少了服务器的负担，大大提高了网站性能")]),t._v(" "),v("li",[t._v("加快了客户端加载网页的速度 这也正是HTTP缓存属于客户端缓存的原因。")])]),t._v(" "),v("h3",{attrs:{id:"_7-2-http缓存两种方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-http缓存两种方式"}},[t._v("#")]),t._v(" 7.2 http缓存两种方式")]),t._v(" "),v("ul",[v("li",[v("p",[v("strong",[t._v("强制缓存")]),t._v("（资源不经常更新使用，网站的首页或者官网一些的）")]),t._v(" "),v("p",[t._v("当缓存数据库中有客户端需要的数据，客户端直接将数据从其中拿出来使用（如果数据未失效），当缓存服务器没有需要的数据时，客户端才会向服务端请求。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("协商缓存")]),t._v("（资源总是动态更新）")]),t._v(" "),v("ul",[v("li",[t._v("又称对比缓存。客户端会先从缓存数据库拿到一个缓存的标识，然后向服务端验证标识是否失效，如果没有失效服务端会返回304，这样客户端可以直接去缓存数据库拿出数据，如果失效，服务端会返回新的数据")])])])]),t._v(" "),v("h3",{attrs:{id:"_7-3-不同的刷新规则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-3-不同的刷新规则"}},[t._v("#")]),t._v(" 7.3 不同的刷新规则")]),t._v(" "),v("h5",{attrs:{id:"浏览器地址栏中写入url-回车"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器地址栏中写入url-回车"}},[t._v("#")]),t._v(" "),v("strong",[t._v("浏览器地址栏中写入URL，回车")])]),t._v(" "),v("ul",[v("li",[t._v("浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。（最快）")])]),t._v(" "),v("h5",{attrs:{id:"f5"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#f5"}},[t._v("#")]),t._v(" F5")]),t._v(" "),v("ul",[v("li",[t._v("F5就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就战战兢兢的发送一个请求带上If-Modify-since。")])]),t._v(" "),v("h5",{attrs:{id:"ctrl-f5"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#ctrl-f5"}},[t._v("#")]),t._v(" Ctrl+F5")]),t._v(" "),v("ul",[v("li",[t._v("告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作.")])]),t._v(" "),v("h3",{attrs:{id:"_7-4-缓存总流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-4-缓存总流程"}},[t._v("#")]),t._v(" 7.4 缓存总流程")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/202205011831068.png",alt:"http缓存"}})])])}),[],!1,null,null,null);_.default=r.exports}}]);