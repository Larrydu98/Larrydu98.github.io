(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{586:function(_,t,v){"use strict";v.r(t);var a=v(10),r=Object(a.a)({},(function(){var _=this,t=_.$createElement,v=_._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"_1-数据库如何保证一致性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-数据库如何保证一致性"}},[_._v("#")]),_._v(" 1 数据库如何保证一致性？")]),_._v(" "),v("p",[_._v("分为两个层面来说。")]),_._v(" "),v("p",[_._v("**从数据库层面，**数据库通过原子性、隔离性、持久性来保证一致性。也就是说 ACID 四大特性之中， C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。 数据库必须要实现AID三大特性，才有可能实现一致性。例如，原子性无法保证，显然一致性也无法保 证。")]),_._v(" "),v("p",[_._v("**从应用层面，**通过代码判断数据库数据是否有效，然后决定回滚还是提交数据")]),_._v(" "),v("h2",{attrs:{id:"_2-对mysql的锁了解吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-对mysql的锁了解吗"}},[_._v("#")]),_._v(" 2 对MySQL的锁了解吗")]),_._v(" "),v("p",[_._v("当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机 制就是这样的一个机制。")]),_._v(" "),v("p",[_._v("就像酒店的房间，如果大家随意进出，就会出现多人抢夺同一个房间的情况，而在房间上装上锁，申请到钥匙的人才可以入住并且将房间锁起来，其他人只有等他使用完毕才可以再次使用。")]),_._v(" "),v("p",[_._v("MySQL中的锁，按照锁的粒度分，分为以下三类：")]),_._v(" "),v("h3",{attrs:{id:"全局锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#全局锁"}},[_._v("#")]),_._v(" 全局锁")]),_._v(" "),v("p",[_._v("全局锁就是对整个数据库实例加锁，加锁后整个实例就处于"),v("strong",[_._v("只读状态")]),_._v("，后续的DML（对数据库进行的简单操作，insert、delete、update、select）的写语句，DDL（对数据库对象进行管理。create,alter,drop）语句，已经更新操作的事务提交语句都将被阻塞。")]),_._v(" "),v("p",[v("strong",[_._v("使用在全库的逻辑备份")])]),_._v(" "),v("h3",{attrs:{id:"表级锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#表级锁"}},[_._v("#")]),_._v(" 表级锁")]),_._v(" "),v("p",[_._v("每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。")]),_._v(" "),v("h4",{attrs:{id:"表锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#表锁"}},[_._v("#")]),_._v(" 表锁")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("表共享读锁(read lock)")]),_._v(" "),v("p",[_._v("不会阻塞读，但是会阻塞写入")])]),_._v(" "),v("li",[v("p",[_._v("表独占写锁(write lock)")]),_._v(" "),v("p",[_._v("加锁的客户端可读，可写，但是其他客户端不能读写")])])]),_._v(" "),v("h4",{attrs:{id:"元数据锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#元数据锁"}},[_._v("#")]),_._v(" 元数据锁")]),_._v(" "),v("p",[_._v("为了避免DML与DDL冲突，保证读写的正确性。")]),_._v(" "),v("h4",{attrs:{id:"意向锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#意向锁"}},[_._v("#")]),_._v(" 意向锁")]),_._v(" "),v("p",[_._v("为了避免DML在执行时，加的行锁与表锁的冲突，在IoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。")]),_._v(" "),v("h3",{attrs:{id:"行级锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#行级锁"}},[_._v("#")]),_._v(" 行级锁：")]),_._v(" "),v("p",[v("strong",[_._v("共享锁：")]),_._v(" 又叫做读锁。当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。")]),_._v(" "),v("p",[_._v("**排他锁：**又叫做写锁。当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/202205171720375.png",alt:"image-20220517172053328"}})]),_._v(" "),v("p",[_._v("每次操作锁住对应的行数据。")]),_._v(" "),v("p",[_._v("会出现死锁，发生锁冲突几率低，并发高。在MySQL的InnoDB引擎支持行锁，与Oracle不同，MySQL 的行锁是通过索引加载的，也就是说，行锁 是加在索引响应的行上的，要是对应的SQL语句没有走索引，则会全表扫描，行锁则无法实现，取而代 之的是表锁，此时其它事务无法对当前表进行更新或插入操作。")]),_._v(" "),v("h2",{attrs:{id:"_3-隔离级别与锁的关系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-隔离级别与锁的关系"}},[_._v("#")]),_._v(" 3 隔离级别与锁的关系")]),_._v(" "),v("p",[_._v("为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、 不可重复读、幻读这几类问题。")]),_._v(" "),v("ul",[v("li",[_._v("READ-UNCOMMITTED(读取未提交)：最低的隔离级别，允许读取尚未提交的数据变更，可能会导 致脏读、幻读或不可重复读。")]),_._v(" "),v("li",[_._v("READ-COMMITTED(读取已提交)：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读 或不可重复读仍有可能发生。")]),_._v(" "),v("li",[_._v("REPEATABLE-READ(可重复读)：对同一字段的多次读取结果都是一致的，除非数据是被本身事务 自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。")]),_._v(" "),v("li",[_._v("SERIALIZABLE(可串行化)：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执 行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻 读。")])]),_._v(" "),v("p",[_._v("Mysql 默认采用的 REPEATABLE_READ隔离级别")]),_._v(" "),v("p",[_._v("事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过 保存修改的旧版本信息来支持并发一致性读和回滚等特性。")]),_._v(" "),v("h2",{attrs:{id:"_4-什么是死锁-怎么解决"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-什么是死锁-怎么解决"}},[_._v("#")]),_._v(" 4 什么是死锁？怎么解决？")]),_._v(" "),v("p",[_._v("死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/202205171707749.png",alt:"image-20220517170704715"}})]),_._v(" "),v("p",[_._v("互斥条件，请求和保持条件，环路等待条件，不剥夺条件。")]),_._v(" "),v("p",[_._v("解决死锁思路，一般就是切断环路，尽量避免并发形成环路。")]),_._v(" "),v("ul",[v("li",[_._v("如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。")]),_._v(" "),v("li",[_._v("在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；")]),_._v(" "),v("li",[_._v("对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；")]),_._v(" "),v("li",[_._v("如果业务处理不好可以用分布式事务锁或者使用乐观锁")]),_._v(" "),v("li",[_._v("死锁与索引密不可分，解决索引问题，需要合理优化你的索引，")])]),_._v(" "),v("h2",{attrs:{id:"_5-数据库的乐观锁和悲观锁是什么-怎么实现的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-数据库的乐观锁和悲观锁是什么-怎么实现的"}},[_._v("#")]),_._v(" 5 数据库的乐观锁和悲观锁是什么？怎么实现的？")]),_._v(" "),v("p",[_._v("数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏 事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并 发控制主要采用的技术手段。")]),_._v(" "),v("p",[v("strong",[_._v("悲观锁")]),_._v("：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁 起来，直到提交事务。实现方式：使用数据库中的锁机制")]),_._v(" "),v("p",[v("strong",[_._v("乐观锁")]),_._v("：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务 锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。")]),_._v(" "),v("h3",{attrs:{id:"两种锁的使用场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#两种锁的使用场景"}},[_._v("#")]),_._v(" 两种锁的使用场景")]),_._v(" "),v("p",[_._v("像乐观锁适用于写比 较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整 个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低 了性能，所以一般多写的场景下用悲观锁就比较合适。")]),_._v(" "),v("h2",{attrs:{id:"_6-存储引擎选择"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-存储引擎选择"}},[_._v("#")]),_._v(" 6 存储引擎选择")]),_._v(" "),v("p",[_._v("如果没有特别的需求，使用默认的Innodb即可。")]),_._v(" "),v("p",[_._v("MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。")]),_._v(" "),v("p",[_._v("Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如OA自动化办公系统。")])])}),[],!1,null,null,null);t.default=r.exports}}]);