(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{595:function(t,a,_){"use strict";_.r(a);var r=_(10),v=Object(r.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("p",[t._v("总结常见的数据结构")]),t._v(" "),_("h2",{attrs:{id:"线性数据结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线性数据结构"}},[t._v("#")]),t._v(" 线性数据结构")]),t._v(" "),_("h3",{attrs:{id:"_1-数组"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-数组"}},[t._v("#")]),t._v(" 1 数组")]),t._v(" "),_("p",[_("strong",[t._v("数组（Array）")]),t._v(" 是一种很常见的数据结构。它由相同类型的元素（element）组成,并且使用的是一块联系的内存进行存储的，我们可以直接利用元素的索引来计算出该元素的存储位置")]),t._v(" "),_("p",[t._v("数组的特点是："),_("strong",[t._v("提供随机访问")]),t._v(" 并且容量有限。")]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"title"}),_("p",[t._v("假如数组的长度为 n。\n"),_("strong",[t._v("访问：O（1）")]),t._v("//访问特定位置的元素\n"),_("strong",[t._v("插入：O（n ）")]),t._v("//最坏的情况发生在插入发生在数组的首部并需要移动所有元素时\n"),_("strong",[t._v("删除：O（n）")]),t._v("//最坏的情况发生在删除数组的开头发生并需要移动第一元素后面所有的元素时")])]),_("h3",{attrs:{id:"_2-链表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-链表"}},[t._v("#")]),t._v(" 2 链表")]),t._v(" "),_("h4",{attrs:{id:"_2-1-链表简介"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-链表简介"}},[t._v("#")]),t._v(" 2.1 链表简介")]),t._v(" "),_("p",[_("strong",[t._v("链表（LinkedList）")]),t._v(" 虽然是一种线性表，但是并不会按线性的顺序存储数据，使用的不是连续的内存空间来存储数据。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/20200806194613920.png",alt:"链表3"}})]),t._v(" "),_("p",[t._v("链表的"),_("strong",[t._v("插入和删除操作的复杂度为 O(1)")]),t._v(" ，只需要知道目标位置元素的上一个元素即可。但是，在"),_("strong",[t._v("查找")]),t._v("一个节点或者访问特定位置的节点的时候"),_("strong",[t._v("复杂度为 O(n)")]),t._v(" 。")]),t._v(" "),_("h4",{attrs:{id:"_2-2-链表分类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-链表分类"}},[t._v("#")]),t._v(" 2.2. 链表分类")]),t._v(" "),_("p",[_("strong",[t._v("常见链表分类：")])]),t._v(" "),_("ol",[_("li",[_("strong",[t._v("单链表")])])]),t._v(" "),_("p",[t._v("​\t单向链表只有一个方向，结点只有一个后继指针 next 指向后面的节点。，在物理内存上是不连续的，通常吧第一个节点叫为头结点")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/20200806194529815.png",alt:"链表1"}})]),t._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[_("p",[_("strong",[t._v("双向链表")])]),t._v(" "),_("p",[t._v("每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。既可以向前查询也可以向后查询")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/20200806194559317.png",alt:"链表2"}})])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("循环链表")])]),t._v(" "),_("p",[t._v("循环链表，顾名思义，就是链表首尾相连。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/20200806194629603.png",alt:"链表4"}})])])]),t._v(" "),_("h4",{attrs:{id:"_2-3-数组和链表对比"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-数组和链表对比"}},[t._v("#")]),t._v(" 2.3 数组和链表对比")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/20200806195200276.png",alt:"链表-链表与数据性能对比"}})]),t._v(" "),_("p",[t._v("数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。")]),t._v(" "),_("p",[t._v("链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。")]),t._v(" "),_("h3",{attrs:{id:"_3-栈-stack"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-栈-stack"}},[t._v("#")]),t._v(" 3 栈（stack）")]),t._v(" "),_("p",[_("strong",[t._v("栈")]),t._v(" (stack)堆也是栈的一种，只允许在有序的线性数据集合的一端（称为栈顶 top）进行加入数据（push）和移除数据（pop）。因而按照 "),_("strong",[t._v("后进先出（LIFO, Last In First Out）")]),t._v(" 的原理运作。"),_("strong",[t._v("在栈中，push 和 pop 的操作都发生在栈顶。")])]),t._v(" "),_("p",[t._v("栈常用一维数组或链表来实现，用数组实现的栈叫作 "),_("strong",[t._v("顺序栈")]),t._v(" ，用链表实现的栈叫作 "),_("strong",[t._v("链式栈")]),t._v(" 。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/%E6%A0%88.png",alt:"栈"}})]),t._v(" "),_("h3",{attrs:{id:"_4-队列-queue"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-队列-queue"}},[t._v("#")]),t._v(" 4 队列（queue）")]),t._v(" "),_("p",[_("strong",[t._v("队列")]),t._v(" 是 "),_("strong",[t._v("先进先出( FIFO，First In, First Out)")]),t._v(" 的线性表。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/20210104235346563.png",alt:"栈与队列理论1"}})]),t._v(" "),_("h2",{attrs:{id:"非线性数据结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#非线性数据结构"}},[t._v("#")]),t._v(" 非线性数据结构")]),t._v(" "),_("h3",{attrs:{id:"_1-树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-树"}},[t._v("#")]),t._v(" 1 树")]),t._v(" "),_("p",[t._v("树就是一种类似现实生活中的树的数据结构（倒置的树）。任何一颗非空树只有一个根节点。")]),t._v(" "),_("p",[t._v("一棵树具有以下特点：")]),t._v(" "),_("ol",[_("li",[t._v("一棵树中的任意两个结点有且仅有唯一的一条路径连通。")]),t._v(" "),_("li",[t._v("一棵树如果有 n 个结点，那么它一定恰好有 n-1 条边。")]),t._v(" "),_("li",[t._v("一棵树不包含回路。")])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/%E4%BA%8C%E5%8F%89%E6%A0%91-2-20220426101236320.png",alt:""}})]),t._v(" "),_("p",[t._v("如上图所示，通过上面这张图说明一下树中的常用概念：")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("节点")]),t._v(" ：树中的每个元素都可以统称为节点。")]),t._v(" "),_("li",[_("strong",[t._v("根节点")]),t._v(" ：顶层节点或者"),_("strong",[t._v("说没有父节点的节点")]),t._v("。上图中 A 节点就是根节点。")]),t._v(" "),_("li",[_("strong",[t._v("父节点")]),t._v(" ：若一个节点含有子节点，则这个节点称为其子节点的父节点。上图中的 B 节点是 D 节点、E 节点的父节点。")]),t._v(" "),_("li",[_("strong",[t._v("子节点")]),t._v(" ：一个节点含有的子树的根节点称为该节点的子节点。上图中 D 节点、E 节点是 B 节点的子节点。")]),t._v(" "),_("li",[_("strong",[t._v("兄弟节点")]),t._v(" ：具有相同父节点的节点互称为兄弟节点。上图中 D 节点、E 节点的共同父节点是 B 节点，故 D 和 E 为兄弟节点。")]),t._v(" "),_("li",[_("strong",[t._v("叶子节点")]),t._v(" ：没有子节点的节点。上图中的 D、F、H、I 都是叶子节点。")]),t._v(" "),_("li",[_("strong",[t._v("节点的高度")]),t._v(" ：该节点到叶子节点的最长路径所包含的节点数。")]),t._v(" "),_("li",[_("strong",[t._v("节点的深度")]),t._v(" ：根节点到该节点的路径所包含的边节点数（不包过此节点）")]),t._v(" "),_("li",[_("strong",[t._v("节点的层数")]),t._v(" ：节点的深度+1。")]),t._v(" "),_("li",[_("strong",[t._v("树的高度")]),t._v(" ：根节点的高度。")])]),t._v(" "),_("h4",{attrs:{id:"满二叉树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#满二叉树"}},[t._v("#")]),t._v(" 满二叉树")]),t._v(" "),_("p",[t._v("一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是 "),_("strong",[t._v("满二叉树")]),t._v("。也就是说，如果一个二叉树的层数为 K，且结点总数是(2^k) -1 ，则它就是 "),_("strong",[t._v("满二叉树")]),t._v("。如下图所示：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://snailclimb.gitee.io/javaguide/docs/cs-basics/data-structure/pictures/%E6%A0%91/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png",alt:"img"}})]),t._v(" "),_("h4",{attrs:{id:"完全二叉树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#完全二叉树"}},[t._v("#")]),t._v(" 完全二叉树")]),t._v(" "),_("p",[t._v("除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则这个二叉树就是 "),_("strong",[t._v("完全二叉树")]),t._v(" 。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/20200920221638903.png",alt:"img"}})]),t._v(" "),_("h4",{attrs:{id:"平衡二叉树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#平衡二叉树"}},[t._v("#")]),t._v(" 平衡二叉树")]),t._v(" "),_("p",[_("strong",[t._v("平衡二叉树")]),t._v(" 是一棵二叉排序树，且具有以下性质：")]),t._v(" "),_("ol",[_("li",[t._v("可以是一棵空树")]),t._v(" "),_("li",[t._v("如果不是空树，它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。")])]),t._v(" "),_("p",[t._v("平衡二叉树的常用实现方法有 "),_("strong",[t._v("红黑树")]),t._v("、"),_("strong",[t._v("AVL 树")]),t._v("、"),_("strong",[t._v("替罪羊树")]),t._v("、"),_("strong",[t._v("加权平衡树")]),t._v("、"),_("strong",[t._v("伸展树")]),t._v(" 等。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://snailclimb.gitee.io/javaguide/docs/cs-basics/data-structure/pictures/%E6%A0%91/%E6%96%9C%E6%A0%91.png",alt:"img"}})]),t._v(" "),_("h4",{attrs:{id:"二叉树的存储"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的存储"}},[t._v("#")]),t._v(" 二叉树的存储")]),t._v(" "),_("p",[_("strong",[t._v("链式存储")])]),t._v(" "),_("p",[t._v("和链表类似，二叉树的链式存储依靠指针将各个节点串联起来，不需要连续的存储空间。")]),t._v(" "),_("p",[t._v("每个节点包括三个属性：")]),t._v(" "),_("ul",[_("li",[t._v("数据 data。data 不一定是单一的数据，根据不同情况，可以是多个具有不同类型的数据。")]),t._v(" "),_("li",[t._v("左节点指针 left")]),t._v(" "),_("li",[t._v("右节点指针 right。")])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/20220426105323.png",alt:"img"}})]),t._v(" "),_("p",[_("strong",[t._v("顺序存储")])]),t._v(" "),_("p",[t._v("顺序存储就是利用数组进行存储，数组中的每一个位置仅存储节点的 data，不存储左右子节点的指针，子节点的索引通过数组下标完成。根结点的序号为 1，对于每个节点 Node，假设它存储在数组中下标为 i 的位置，那么它的左子节点就存储在 2 * i 的位置，它的右子节点存储在下标为 2 *i+1 的位置。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/20220426105529.png",alt:"img"}})]),t._v(" "),_("h4",{attrs:{id:"二叉树的遍历"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的遍历"}},[t._v("#")]),t._v(" 二叉树的遍历")]),t._v(" "),_("ul",[_("li",[_("p",[_("strong",[t._v("前序遍历")]),t._v("（递归法，迭代法）")]),t._v(" "),_("p",[t._v("中左右")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("中序遍历")]),t._v("（递归法，迭代法）")]),t._v(" "),_("p",[t._v("左中右")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("后序遍历")]),t._v("（递归法，迭代法）")]),t._v(" "),_("p",[t._v("左右中")])]),t._v(" "),_("li",[_("p",[t._v("层序遍历（迭代法）")])])]),t._v(" "),_("h3",{attrs:{id:"_2-堆"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-堆"}},[t._v("#")]),t._v(" 2 堆")]),t._v(" "),_("h4",{attrs:{id:"什么是堆"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是堆"}},[t._v("#")]),t._v(" 什么是堆")]),t._v(" "),_("p",[t._v("堆是一种满足以下条件的树：")]),t._v(" "),_("p",[t._v("堆中的每一个节点值都大于等于（或小于等于）子树中所有节点的值。或者说，任意一个节点的值都大于等于（或小于等于）所有子节点的值。")]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"title"}),_("ul",[_("li",[t._v("很多博客说堆是完全二叉树，其实并非如此，"),_("strong",[t._v("堆不一定是完全二叉树")]),t._v("，只是为了方便存储和索引，我们通常用完全二叉树的形式来表示堆，事实上，广为人知的斐波那契堆和二项堆就不是完全二叉树,它们甚至都不是二叉树。")]),t._v(" "),_("li",[t._v("（"),_("strong",[t._v("二叉")]),t._v("）堆是一个数组，它可以被看成是一个 "),_("strong",[t._v("近似的完全二叉树")]),t._v("。——《算法导论》第三版")])])]),_("h4",{attrs:{id:"堆的用途"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#堆的用途"}},[t._v("#")]),t._v(" "),_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/image-20220426110459145.png",alt:"image-20220426110459145"}}),t._v("堆的用途")]),t._v(" "),_("p",[t._v("当我们只关心所有数据中的最大值或者最小值，存在多次获取最大值或者最小值，多次插入或删除数据时，就可以使用堆。")]),t._v(" "),_("p",[_("strong",[t._v("相对于有序数组而言，堆的主要优势在于更新数据效率较高。")]),t._v(" 堆的初始化时间复杂度为 "),_("code",[t._v("O(nlog(n))")]),t._v("，堆可以做到"),_("code",[t._v("O(1)")]),t._v("时间复杂度取出最大值或者最小值，"),_("code",[t._v("O(log(n))")]),t._v("时间复杂度插入或者删除数据，具体操作在后续章节详细介绍。")]),t._v(" "),_("h4",{attrs:{id:"堆的分类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#堆的分类"}},[t._v("#")]),t._v(" 堆的分类")]),t._v(" "),_("p",[t._v("堆分为 "),_("strong",[t._v("最大堆")]),t._v(" 和 "),_("strong",[t._v("最小堆")]),t._v("。二者的区别在于节点的排序方式。")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("最大堆")]),t._v(" ：堆中的每一个节点的值都大于等于子树中所有节点的值")]),t._v(" "),_("li",[_("strong",[t._v("最小堆")]),t._v(" ：堆中的每一个节点的值都小于等于子树中所有节点的值")])]),t._v(" "),_("p",[t._v("上图1是最大堆，上图二是最小堆")]),t._v(" "),_("h4",{attrs:{id:"堆的存储"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#堆的存储"}},[t._v("#")]),t._v(" 堆的存储")]),t._v(" "),_("p",[t._v("利用数组存储堆")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/image-20220426110835927.png",alt:"image-20220426110835927"}})]),t._v(" "),_("h3",{attrs:{id:"_3-图"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-图"}},[t._v("#")]),t._v(" 3 图")]),t._v(" "),_("p",[t._v("图是一个较为复杂的非线性结构")]),t._v(" "),_("p",[t._v("根据前面的内容，我们知道：")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("线性数据结构")]),t._v("的元素满足唯一的线性关系，每个元素(除第一个和最后一个外)只有一个直接前趋和一个直接后继。")]),t._v(" "),_("li",[t._v("树形数据结构的元素之间有着明显的层次关系。")])]),t._v(" "),_("p",[t._v("但是，图形结构的元素之间的关系是任意的。")]),t._v(" "),_("p",[_("strong",[t._v("何为图呢？")]),t._v(" 简单来说，图就是由顶点的有穷非空集合和顶点之间的边组成的集合。通常表示为："),_("strong",[t._v("G(V,E)")]),t._v("，其中，G表示一个图，V表示顶点的集合，E表示边的集合。")]),t._v(" "),_("p",[t._v("下图所展示的就是图这种数据结构，并且还是一张有向图。")]),t._v(" "),_("p",[t._v("图在我们日常生活中的例子很多！比如我们在社交软件上好友关系就可以用图来表示。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/7f232c9660c54ee1ac182b7c0bf267a3.png",alt:"img"}})]),t._v(" "),_("h4",{attrs:{id:"图的基本概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#图的基本概念"}},[t._v("#")]),t._v(" "),_("strong",[t._v("图的基本概念")])]),t._v(" "),_("p",[_("strong",[t._v("顶点")])]),t._v(" "),_("p",[t._v("图中的数据元素，我们称之为顶点，图至少有一个顶点（非空有穷集合），对应到好友关系图，每一个用户就代表一个顶点。")]),t._v(" "),_("p",[_("strong",[t._v("边")])]),t._v(" "),_("p",[t._v("顶点之间的关系用边表示。对应到好友关系图，两个用户是好友的话，那两者之间就存在一条边。")]),t._v(" "),_("p",[_("strong",[t._v("度")])]),t._v(" "),_("p",[t._v("度表示一个顶点包含多少条边，在有向图中，还分为出度和入度，出度表示从该顶点出去的边的条数，入度表示进入该顶点的边的条数。")]),t._v(" "),_("p",[t._v("对应到好友关系图，度就代表了某个人的好友数量。")]),t._v(" "),_("h4",{attrs:{id:"无向图和有向图"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#无向图和有向图"}},[t._v("#")]),t._v(" 无向图和有向图")]),t._v(" "),_("p",[t._v("边表示的是顶点之间的关系，有的关系是双向的，比如同学关系，A是B的同学，那么B也肯定是A的同学，那么在表示A和B的关系时，就不用关注方向，用不带箭头的边表示，这样的图就是无向图。")]),t._v(" "),_("p",[t._v("有的关系是有方向的，比如父子关系，师生关系，微博的关注关系，A是B的爸爸，但B肯定不是A的爸爸，A关注B，B不一定关注A。在这种情况下，我们就用带箭头的边表示二者的关系，这样的图就是有向图。")]),t._v(" "),_("h4",{attrs:{id:"无权图和有权图"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#无权图和有权图"}},[t._v("#")]),t._v(" 无权图和有权图")]),t._v(" "),_("p",[t._v("对于一个关系，如果我们只关心关系的有无，而不关心关系有多强，那么就可以用无权图表示二者的关系。")]),t._v(" "),_("p",[t._v("对于一个关系，如果我们既关心关系的有无，也关心关系的强度，比如描述地图上两个城市的关系，需要用到距离，那么就用带权图来表示，带权图中的每一条边一个数值表示权值，代表关系的强度。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/image-20220426111825943.png",alt:"image-20220426111825943"}})]),t._v(" "),_("h4",{attrs:{id:"图的存储"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#图的存储"}},[t._v("#")]),t._v(" 图的存储")]),t._v(" "),_("p",[_("strong",[t._v("邻接矩阵存储")])]),t._v(" "),_("p",[t._v("邻接矩阵将图用二维矩阵存储，是一种较为直观的表示方式。")]),t._v(" "),_("p",[t._v("如果第i个顶点和第j个顶点之间有关系，且关系权值为n，则 "),_("code",[t._v("A[i][j]=n")]),t._v(" 。")]),t._v(" "),_("p",[t._v("在无向图中，我们只关心关系的有无，所以当顶点i和顶点j有关系时，"),_("code",[t._v("A[i][j]")]),t._v("=1，当顶点i和顶点j没有关系时，"),_("code",[t._v("A[i][j]")]),t._v("=0。如下图所示：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/image-20220426112020673.png",alt:"image-20220426112020673"}})]),t._v(" "),_("p",[t._v("值得注意的是："),_("strong",[t._v("无向图的邻接矩阵是一个对称矩阵，因为在无向图中，顶点i和顶点j有关系，则顶点j和顶点i必有关系。")])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/image-20220426112112858.png",alt:"image-20220426112112858"}})]),t._v(" "),_("p",[t._v("邻接矩阵存储的方式优点是简单直接（直接使用一个二维数组即可），并且，在获取两个定点之间的关系的时候也非常高效（直接获取指定位置的数组元素的值即可）。但是，这种存储方式的缺点也比较明显，那就是比较浪费空间，")]),t._v(" "),_("p",[_("strong",[t._v("邻接表存储")])]),t._v(" "),_("p",[t._v("针对上面邻接矩阵比较浪费内存空间的问题，诞生了图的另外一种存储方法—"),_("strong",[t._v("邻接表")]),t._v(" 。")]),t._v(" "),_("p",[t._v("邻接链表使用一个链表来存储某个顶点的所有后继相邻顶点。对于图中每个顶点Vi，把所有邻接于Vi的顶点Vj链成一个单链表，这个单链表称为顶点Vi的 "),_("strong",[t._v("邻接表")]),t._v("。如下图所示：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/image-20220426112302147.png",alt:"image-20220426112302147"}})]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/image-20220426112323566.png",alt:"image-20220426112323566"}})]),t._v(" "),_("p",[t._v("大家可以数一数邻接表中所存储的元素的个数以及图中边的条数，你会发现：")]),t._v(" "),_("ul",[_("li",[t._v("在无向图中，邻接表元素个数等于边的条数的两倍，如左图所示的无向图中，边的条数为7，邻接表存储的元素个数为14。")]),t._v(" "),_("li",[t._v("在有向图中，邻接表元素个数等于边的条数，如右图所示的有向图中，边的条数为8，邻接表存储的元素个数为8。")])]),t._v(" "),_("h4",{attrs:{id:"图的搜索"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#图的搜索"}},[t._v("#")]),t._v(" 图的搜索")]),t._v(" "),_("p",[_("strong",[t._v("广度优先搜索")])]),t._v(" "),_("p",[t._v("广度优先搜索就像水面上的波纹一样一层一层向外扩展，如下图所示：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/image-20220426112449193.png",alt:"image-20220426112449193"}})]),t._v(" "),_("p",[_("strong",[t._v("广度优先搜索的具体实现方式用到了之前所学过的线性数据结构——队列")]),t._v(" 。具体过程如下图所示：")]),t._v(" "),_("ol",[_("li",[_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/image-20220426112544921.png",alt:"image-20220426112544921"}})]),t._v(" "),_("li",[_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/image-20220426112559697.png",alt:"image-20220426112559697"}})]),t._v(" "),_("li",[_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/image-20220426112610720.png",alt:"image-20220426112610720"}})]),t._v(" "),_("li",[_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/image-20220426112622198.png",alt:"image-20220426112622198"}})]),t._v(" "),_("li",[_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/image-20220426112631996.png",alt:"image-20220426112631996"}})]),t._v(" "),_("li",[_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/image-20220426112644195.png",alt:"image-20220426112644195"}})])]),t._v(" "),_("p",[_("strong",[t._v("深度优先搜索")])]),t._v(" "),_("p",[t._v("深度优先搜索就是“一条路走到黑”，从源顶点开始，一直走到没有后继节点，才回溯到上一顶点，然后继续“一条路走到黑”，如下图所示：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/image-20220426112720334.png",alt:"image-20220426112720334"}})]),t._v(" "),_("p",[_("strong",[t._v("和广度优先搜索类似，深度优先搜索的具体实现用到了另一种线性数据结构——栈")]),t._v(" 。具体过程如下图所示：")]),t._v(" "),_("ol",[_("li",[_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/image-20220426112755115.png",alt:"image-20220426112755115"}})]),t._v(" "),_("li",[_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/image-20220426112806013.png",alt:"image-20220426112806013"}})]),t._v(" "),_("li",[_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/image-20220426112817394.png",alt:"image-20220426112817394"}})]),t._v(" "),_("li",[_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/image-20220426112829352.png",alt:"image-20220426112829352"}})]),t._v(" "),_("li",[_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/image-20220426112839965.png",alt:"image-20220426112839965"}})]),t._v(" "),_("li",[_("img",{attrs:{src:"https://raw.githubusercontent.com/Larrydu98/BlogIMage/main/image-20220426112851800.png",alt:"image-20220426112851800"}})])])])}),[],!1,null,null,null);a.default=v.exports}}]);